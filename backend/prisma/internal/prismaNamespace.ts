/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from '@prisma/client/runtime/client'
import type * as Prisma from '../models.js'
import { type PrismaClient } from './class.js'

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
	client: string
	engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
	client: '7.2.0',
	engine: '0c8ef2ce45c83248ab3df073180d5eda9e8be7a3',
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue

export const NullTypes = {
	DbNull: runtime.NullTypes.DbNull as new (secret: never) => typeof runtime.DbNull,
	JsonNull: runtime.NullTypes.JsonNull as new (secret: never) => typeof runtime.JsonNull,
	AnyNull: runtime.NullTypes.AnyNull as new (secret: never) => typeof runtime.AnyNull,
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull

type SelectAndInclude = {
	select: any
	include: any
}

type SelectAndOmit = {
	select: any
	omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
	[P in K]: T[P]
}

export type Enumerable<T> = T | Array<T>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
	[key in keyof T]: key extends keyof U ? T[key] : never
}

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
	[key in keyof T]: key extends keyof U ? T[key] : never
} & (T extends SelectAndInclude
	? 'Please either choose `select` or `include`.'
	: T extends SelectAndOmit
		? 'Please either choose `select` or `omit`.'
		: {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
	[key in keyof T]: key extends keyof U ? T[key] : never
} & K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
	T extends Array<any>
		? False
		: T extends Date
			? False
			: T extends Uint8Array
				? False
				: T extends BigInt
					? False
					: T extends object
						? True
						: False

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
	{
		// Merge all but K
		[P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
	}[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<O extends object, K extends Key, strict extends Boolean> = {
	1: EitherStrict<O, K>
	0: EitherLoose<O, K>
}[strict]

export type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
	[K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never

export type Overwrite<O extends object, O1 extends object> = {
	[K in keyof O]: K extends keyof O1 ? O1[K] : O[K]
} & {}

type _Merge<U extends object> = IntersectOf<
	Overwrite<
		U,
		{
			[K in keyof U]-?: At<U, K>
		}
	>
>

type Key = string | number | symbol
type AtStrict<O extends object, K extends Key> = O[K & keyof O]
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
	1: AtStrict<O, K>
	0: AtLoose<O, K>
}[strict]

export type ComputeRaw<A extends any> = A extends Function
	? A
	: {
			[K in keyof A]: A[K]
		} & {}

export type OptionalFlat<O> = {
	[K in keyof O]?: O[K]
} & {}

type _Record<K extends keyof any, T> = {
	[P in K]: T
}

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
	O extends unknown ? (K extends keyof O ? { [P in K]: O[P] } & O : O) | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O) : never
>

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never

export type Strict<U extends object> = ComputeRaw<_Strict<U>>
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
	0: 1
	1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
	? 0 // anything `never` is false
	: A1 extends A2
		? 1
		: 0

export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
	0: {
		0: 0
		1: 1
	}
	1: {
		0: 1
		1: 1
	}
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object
	? {
			[P in keyof T]: P extends keyof O ? O[P] : never
		}
	: never

type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
	[K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
		? // infer is only needed to not hit TS limit
			// based on the brilliant idea of Pierre-Antoine Mills
			// https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
			T[K] extends infer TK
			? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
			: never
		: {} extends FieldPaths<T[K]>
			? never
			: K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

export const ModelName = {
	Settings: 'Settings',
	BasePreference: 'BasePreference',
	Preference: 'Preference',
	User: 'User',
	Account: 'Account',
	UnlinkedAccount: 'UnlinkedAccount',
	Session: 'Session',
	AccessToken: 'AccessToken',
	Committee: 'Committee',
	CommitteeMember: 'CommitteeMember',
	Strafbak: 'Strafbak',
	Maluspunt: 'Maluspunt',
	Activity: 'Activity',
	ActivityLocation: 'ActivityLocation',
	Attending: 'Attending',
	Ledger: 'Ledger',
	ProductCategory: 'ProductCategory',
	Product: 'Product',
	FinancialPerson: 'FinancialPerson',
	FinancialPersonDataUser: 'FinancialPersonDataUser',
	FinancialGroup: 'FinancialGroup',
	FinancialGroupPersonElement: 'FinancialGroupPersonElement',
	FinancialPersonDataActivity: 'FinancialPersonDataActivity',
	FinancialPersonDataCommittee: 'FinancialPersonDataCommittee',
	FinancialPersonDataOther: 'FinancialPersonDataOther',
	Transaction: 'Transaction',
	TransactionMatchRow: 'TransactionMatchRow',
	SaldoTransaction: 'SaldoTransaction',
	BankTransaction: 'BankTransaction',
	Streeplijst: 'Streeplijst',
	Journal: 'Journal',
	DeclarationData: 'DeclarationData',
	JournalRow: 'JournalRow',
	Link: 'Link',
	LinkClick: 'LinkClick',
	EmailAlias: 'EmailAlias',
	EmailAliasCommittee: 'EmailAliasCommittee',
	EmailAliasUser: 'EmailAliasUser',
	EmailContact: 'EmailContact',
	ClickSession: 'ClickSession',
	Track: 'Track',
	TrackReaction: 'TrackReaction',
	Photo: 'Photo',
	PhotoTag: 'PhotoTag',
	PhotosWithTags: 'PhotosWithTags',
	PhotoPersonTag: 'PhotoPersonTag',
	PhotoRating: 'PhotoRating',
	Comment: 'Comment',
	Leaderboard: 'Leaderboard',
	LeaderboardEntry: 'LeaderboardEntry',
	LeaderboardChallenger: 'LeaderboardChallenger',
	LeaderboardChallengerUser: 'LeaderboardChallengerUser',
	File: 'File',
	Job: 'Job',
	Notification: 'Notification',
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]

export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<
	{ extArgs: runtime.Types.Extensions.InternalArgs },
	runtime.Types.Utils.Record<string, any>
> {
	returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> = {
	globalOmitOptions: {
		omit: GlobalOmitOptions
	}
	meta: {
		modelProps:
			| 'settings'
			| 'basePreference'
			| 'preference'
			| 'user'
			| 'account'
			| 'unlinkedAccount'
			| 'session'
			| 'accessToken'
			| 'committee'
			| 'committeeMember'
			| 'strafbak'
			| 'maluspunt'
			| 'activity'
			| 'activityLocation'
			| 'attending'
			| 'ledger'
			| 'productCategory'
			| 'product'
			| 'financialPerson'
			| 'financialPersonDataUser'
			| 'financialGroup'
			| 'financialGroupPersonElement'
			| 'financialPersonDataActivity'
			| 'financialPersonDataCommittee'
			| 'financialPersonDataOther'
			| 'transaction'
			| 'transactionMatchRow'
			| 'saldoTransaction'
			| 'bankTransaction'
			| 'streeplijst'
			| 'journal'
			| 'declarationData'
			| 'journalRow'
			| 'link'
			| 'linkClick'
			| 'emailAlias'
			| 'emailAliasCommittee'
			| 'emailAliasUser'
			| 'emailContact'
			| 'clickSession'
			| 'track'
			| 'trackReaction'
			| 'photo'
			| 'photoTag'
			| 'photosWithTags'
			| 'photoPersonTag'
			| 'photoRating'
			| 'comment'
			| 'leaderboard'
			| 'leaderboardEntry'
			| 'leaderboardChallenger'
			| 'leaderboardChallengerUser'
			| 'file'
			| 'job'
			| 'notification'
		txIsolationLevel: TransactionIsolationLevel
	}
	model: {
		Settings: {
			payload: Prisma.$SettingsPayload<ExtArgs>
			fields: Prisma.SettingsFieldRefs
			operations: {
				findUnique: {
					args: Prisma.SettingsFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
				}
				findFirst: {
					args: Prisma.SettingsFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
				}
				findMany: {
					args: Prisma.SettingsFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>[]
				}
				create: {
					args: Prisma.SettingsCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
				}
				createMany: {
					args: Prisma.SettingsCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.SettingsDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
				}
				update: {
					args: Prisma.SettingsUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
				}
				deleteMany: {
					args: Prisma.SettingsDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.SettingsUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.SettingsUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
				}
				aggregate: {
					args: Prisma.SettingsAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateSettings>
				}
				groupBy: {
					args: Prisma.SettingsGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.SettingsGroupByOutputType>[]
				}
				count: {
					args: Prisma.SettingsCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.SettingsCountAggregateOutputType> | number
				}
			}
		}
		BasePreference: {
			payload: Prisma.$BasePreferencePayload<ExtArgs>
			fields: Prisma.BasePreferenceFieldRefs
			operations: {
				findUnique: {
					args: Prisma.BasePreferenceFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.BasePreferenceFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>
				}
				findFirst: {
					args: Prisma.BasePreferenceFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.BasePreferenceFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>
				}
				findMany: {
					args: Prisma.BasePreferenceFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>[]
				}
				create: {
					args: Prisma.BasePreferenceCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>
				}
				createMany: {
					args: Prisma.BasePreferenceCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.BasePreferenceDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>
				}
				update: {
					args: Prisma.BasePreferenceUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>
				}
				deleteMany: {
					args: Prisma.BasePreferenceDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.BasePreferenceUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.BasePreferenceUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BasePreferencePayload>
				}
				aggregate: {
					args: Prisma.BasePreferenceAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateBasePreference>
				}
				groupBy: {
					args: Prisma.BasePreferenceGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.BasePreferenceGroupByOutputType>[]
				}
				count: {
					args: Prisma.BasePreferenceCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.BasePreferenceCountAggregateOutputType> | number
				}
			}
		}
		Preference: {
			payload: Prisma.$PreferencePayload<ExtArgs>
			fields: Prisma.PreferenceFieldRefs
			operations: {
				findUnique: {
					args: Prisma.PreferenceFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.PreferenceFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>
				}
				findFirst: {
					args: Prisma.PreferenceFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.PreferenceFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>
				}
				findMany: {
					args: Prisma.PreferenceFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>[]
				}
				create: {
					args: Prisma.PreferenceCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>
				}
				createMany: {
					args: Prisma.PreferenceCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.PreferenceDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>
				}
				update: {
					args: Prisma.PreferenceUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>
				}
				deleteMany: {
					args: Prisma.PreferenceDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.PreferenceUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.PreferenceUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PreferencePayload>
				}
				aggregate: {
					args: Prisma.PreferenceAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregatePreference>
				}
				groupBy: {
					args: Prisma.PreferenceGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PreferenceGroupByOutputType>[]
				}
				count: {
					args: Prisma.PreferenceCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PreferenceCountAggregateOutputType> | number
				}
			}
		}
		User: {
			payload: Prisma.$UserPayload<ExtArgs>
			fields: Prisma.UserFieldRefs
			operations: {
				findUnique: {
					args: Prisma.UserFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
				}
				findFirst: {
					args: Prisma.UserFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
				}
				findMany: {
					args: Prisma.UserFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
				}
				create: {
					args: Prisma.UserCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
				}
				createMany: {
					args: Prisma.UserCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.UserDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
				}
				update: {
					args: Prisma.UserUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
				}
				deleteMany: {
					args: Prisma.UserDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.UserUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.UserUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
				}
				aggregate: {
					args: Prisma.UserAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
				}
				groupBy: {
					args: Prisma.UserGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
				}
				count: {
					args: Prisma.UserCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
				}
			}
		}
		Account: {
			payload: Prisma.$AccountPayload<ExtArgs>
			fields: Prisma.AccountFieldRefs
			operations: {
				findUnique: {
					args: Prisma.AccountFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
				}
				findFirst: {
					args: Prisma.AccountFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
				}
				findMany: {
					args: Prisma.AccountFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
				}
				create: {
					args: Prisma.AccountCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
				}
				createMany: {
					args: Prisma.AccountCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.AccountDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
				}
				update: {
					args: Prisma.AccountUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
				}
				deleteMany: {
					args: Prisma.AccountDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.AccountUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.AccountUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
				}
				aggregate: {
					args: Prisma.AccountAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
				}
				groupBy: {
					args: Prisma.AccountGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
				}
				count: {
					args: Prisma.AccountCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
				}
			}
		}
		UnlinkedAccount: {
			payload: Prisma.$UnlinkedAccountPayload<ExtArgs>
			fields: Prisma.UnlinkedAccountFieldRefs
			operations: {
				findUnique: {
					args: Prisma.UnlinkedAccountFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.UnlinkedAccountFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>
				}
				findFirst: {
					args: Prisma.UnlinkedAccountFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.UnlinkedAccountFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>
				}
				findMany: {
					args: Prisma.UnlinkedAccountFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>[]
				}
				create: {
					args: Prisma.UnlinkedAccountCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>
				}
				createMany: {
					args: Prisma.UnlinkedAccountCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.UnlinkedAccountDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>
				}
				update: {
					args: Prisma.UnlinkedAccountUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>
				}
				deleteMany: {
					args: Prisma.UnlinkedAccountDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.UnlinkedAccountUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.UnlinkedAccountUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlinkedAccountPayload>
				}
				aggregate: {
					args: Prisma.UnlinkedAccountAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateUnlinkedAccount>
				}
				groupBy: {
					args: Prisma.UnlinkedAccountGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.UnlinkedAccountGroupByOutputType>[]
				}
				count: {
					args: Prisma.UnlinkedAccountCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.UnlinkedAccountCountAggregateOutputType> | number
				}
			}
		}
		Session: {
			payload: Prisma.$SessionPayload<ExtArgs>
			fields: Prisma.SessionFieldRefs
			operations: {
				findUnique: {
					args: Prisma.SessionFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
				}
				findFirst: {
					args: Prisma.SessionFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
				}
				findMany: {
					args: Prisma.SessionFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
				}
				create: {
					args: Prisma.SessionCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
				}
				createMany: {
					args: Prisma.SessionCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.SessionDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
				}
				update: {
					args: Prisma.SessionUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
				}
				deleteMany: {
					args: Prisma.SessionDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.SessionUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.SessionUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
				}
				aggregate: {
					args: Prisma.SessionAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
				}
				groupBy: {
					args: Prisma.SessionGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
				}
				count: {
					args: Prisma.SessionCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
				}
			}
		}
		AccessToken: {
			payload: Prisma.$AccessTokenPayload<ExtArgs>
			fields: Prisma.AccessTokenFieldRefs
			operations: {
				findUnique: {
					args: Prisma.AccessTokenFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.AccessTokenFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>
				}
				findFirst: {
					args: Prisma.AccessTokenFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.AccessTokenFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>
				}
				findMany: {
					args: Prisma.AccessTokenFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
				}
				create: {
					args: Prisma.AccessTokenCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>
				}
				createMany: {
					args: Prisma.AccessTokenCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.AccessTokenDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>
				}
				update: {
					args: Prisma.AccessTokenUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>
				}
				deleteMany: {
					args: Prisma.AccessTokenDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.AccessTokenUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.AccessTokenUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AccessTokenPayload>
				}
				aggregate: {
					args: Prisma.AccessTokenAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateAccessToken>
				}
				groupBy: {
					args: Prisma.AccessTokenGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AccessTokenGroupByOutputType>[]
				}
				count: {
					args: Prisma.AccessTokenCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AccessTokenCountAggregateOutputType> | number
				}
			}
		}
		Committee: {
			payload: Prisma.$CommitteePayload<ExtArgs>
			fields: Prisma.CommitteeFieldRefs
			operations: {
				findUnique: {
					args: Prisma.CommitteeFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.CommitteeFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>
				}
				findFirst: {
					args: Prisma.CommitteeFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.CommitteeFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>
				}
				findMany: {
					args: Prisma.CommitteeFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>[]
				}
				create: {
					args: Prisma.CommitteeCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>
				}
				createMany: {
					args: Prisma.CommitteeCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.CommitteeDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>
				}
				update: {
					args: Prisma.CommitteeUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>
				}
				deleteMany: {
					args: Prisma.CommitteeDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.CommitteeUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.CommitteeUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteePayload>
				}
				aggregate: {
					args: Prisma.CommitteeAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateCommittee>
				}
				groupBy: {
					args: Prisma.CommitteeGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.CommitteeGroupByOutputType>[]
				}
				count: {
					args: Prisma.CommitteeCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.CommitteeCountAggregateOutputType> | number
				}
			}
		}
		CommitteeMember: {
			payload: Prisma.$CommitteeMemberPayload<ExtArgs>
			fields: Prisma.CommitteeMemberFieldRefs
			operations: {
				findUnique: {
					args: Prisma.CommitteeMemberFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.CommitteeMemberFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>
				}
				findFirst: {
					args: Prisma.CommitteeMemberFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.CommitteeMemberFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>
				}
				findMany: {
					args: Prisma.CommitteeMemberFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>[]
				}
				create: {
					args: Prisma.CommitteeMemberCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>
				}
				createMany: {
					args: Prisma.CommitteeMemberCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.CommitteeMemberDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>
				}
				update: {
					args: Prisma.CommitteeMemberUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>
				}
				deleteMany: {
					args: Prisma.CommitteeMemberDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.CommitteeMemberUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.CommitteeMemberUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommitteeMemberPayload>
				}
				aggregate: {
					args: Prisma.CommitteeMemberAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateCommitteeMember>
				}
				groupBy: {
					args: Prisma.CommitteeMemberGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.CommitteeMemberGroupByOutputType>[]
				}
				count: {
					args: Prisma.CommitteeMemberCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.CommitteeMemberCountAggregateOutputType> | number
				}
			}
		}
		Strafbak: {
			payload: Prisma.$StrafbakPayload<ExtArgs>
			fields: Prisma.StrafbakFieldRefs
			operations: {
				findUnique: {
					args: Prisma.StrafbakFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.StrafbakFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>
				}
				findFirst: {
					args: Prisma.StrafbakFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.StrafbakFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>
				}
				findMany: {
					args: Prisma.StrafbakFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>[]
				}
				create: {
					args: Prisma.StrafbakCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>
				}
				createMany: {
					args: Prisma.StrafbakCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.StrafbakDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>
				}
				update: {
					args: Prisma.StrafbakUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>
				}
				deleteMany: {
					args: Prisma.StrafbakDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.StrafbakUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.StrafbakUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StrafbakPayload>
				}
				aggregate: {
					args: Prisma.StrafbakAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateStrafbak>
				}
				groupBy: {
					args: Prisma.StrafbakGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.StrafbakGroupByOutputType>[]
				}
				count: {
					args: Prisma.StrafbakCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.StrafbakCountAggregateOutputType> | number
				}
			}
		}
		Maluspunt: {
			payload: Prisma.$MaluspuntPayload<ExtArgs>
			fields: Prisma.MaluspuntFieldRefs
			operations: {
				findUnique: {
					args: Prisma.MaluspuntFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.MaluspuntFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>
				}
				findFirst: {
					args: Prisma.MaluspuntFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.MaluspuntFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>
				}
				findMany: {
					args: Prisma.MaluspuntFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>[]
				}
				create: {
					args: Prisma.MaluspuntCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>
				}
				createMany: {
					args: Prisma.MaluspuntCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.MaluspuntDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>
				}
				update: {
					args: Prisma.MaluspuntUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>
				}
				deleteMany: {
					args: Prisma.MaluspuntDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.MaluspuntUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.MaluspuntUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$MaluspuntPayload>
				}
				aggregate: {
					args: Prisma.MaluspuntAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateMaluspunt>
				}
				groupBy: {
					args: Prisma.MaluspuntGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.MaluspuntGroupByOutputType>[]
				}
				count: {
					args: Prisma.MaluspuntCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.MaluspuntCountAggregateOutputType> | number
				}
			}
		}
		Activity: {
			payload: Prisma.$ActivityPayload<ExtArgs>
			fields: Prisma.ActivityFieldRefs
			operations: {
				findUnique: {
					args: Prisma.ActivityFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
				}
				findFirst: {
					args: Prisma.ActivityFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
				}
				findMany: {
					args: Prisma.ActivityFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
				}
				create: {
					args: Prisma.ActivityCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
				}
				createMany: {
					args: Prisma.ActivityCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.ActivityDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
				}
				update: {
					args: Prisma.ActivityUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
				}
				deleteMany: {
					args: Prisma.ActivityDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.ActivityUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.ActivityUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
				}
				aggregate: {
					args: Prisma.ActivityAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateActivity>
				}
				groupBy: {
					args: Prisma.ActivityGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ActivityGroupByOutputType>[]
				}
				count: {
					args: Prisma.ActivityCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ActivityCountAggregateOutputType> | number
				}
			}
		}
		ActivityLocation: {
			payload: Prisma.$ActivityLocationPayload<ExtArgs>
			fields: Prisma.ActivityLocationFieldRefs
			operations: {
				findUnique: {
					args: Prisma.ActivityLocationFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.ActivityLocationFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>
				}
				findFirst: {
					args: Prisma.ActivityLocationFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.ActivityLocationFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>
				}
				findMany: {
					args: Prisma.ActivityLocationFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>[]
				}
				create: {
					args: Prisma.ActivityLocationCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>
				}
				createMany: {
					args: Prisma.ActivityLocationCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.ActivityLocationDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>
				}
				update: {
					args: Prisma.ActivityLocationUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>
				}
				deleteMany: {
					args: Prisma.ActivityLocationDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.ActivityLocationUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.ActivityLocationUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLocationPayload>
				}
				aggregate: {
					args: Prisma.ActivityLocationAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateActivityLocation>
				}
				groupBy: {
					args: Prisma.ActivityLocationGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ActivityLocationGroupByOutputType>[]
				}
				count: {
					args: Prisma.ActivityLocationCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ActivityLocationCountAggregateOutputType> | number
				}
			}
		}
		Attending: {
			payload: Prisma.$AttendingPayload<ExtArgs>
			fields: Prisma.AttendingFieldRefs
			operations: {
				findUnique: {
					args: Prisma.AttendingFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.AttendingFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>
				}
				findFirst: {
					args: Prisma.AttendingFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.AttendingFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>
				}
				findMany: {
					args: Prisma.AttendingFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>[]
				}
				create: {
					args: Prisma.AttendingCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>
				}
				createMany: {
					args: Prisma.AttendingCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.AttendingDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>
				}
				update: {
					args: Prisma.AttendingUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>
				}
				deleteMany: {
					args: Prisma.AttendingDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.AttendingUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.AttendingUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendingPayload>
				}
				aggregate: {
					args: Prisma.AttendingAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateAttending>
				}
				groupBy: {
					args: Prisma.AttendingGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AttendingGroupByOutputType>[]
				}
				count: {
					args: Prisma.AttendingCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AttendingCountAggregateOutputType> | number
				}
			}
		}
		Ledger: {
			payload: Prisma.$LedgerPayload<ExtArgs>
			fields: Prisma.LedgerFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LedgerFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LedgerFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>
				}
				findFirst: {
					args: Prisma.LedgerFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LedgerFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>
				}
				findMany: {
					args: Prisma.LedgerFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>[]
				}
				create: {
					args: Prisma.LedgerCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>
				}
				createMany: {
					args: Prisma.LedgerCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LedgerDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>
				}
				update: {
					args: Prisma.LedgerUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>
				}
				deleteMany: {
					args: Prisma.LedgerDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LedgerUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LedgerUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerPayload>
				}
				aggregate: {
					args: Prisma.LedgerAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLedger>
				}
				groupBy: {
					args: Prisma.LedgerGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LedgerGroupByOutputType>[]
				}
				count: {
					args: Prisma.LedgerCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LedgerCountAggregateOutputType> | number
				}
			}
		}
		ProductCategory: {
			payload: Prisma.$ProductCategoryPayload<ExtArgs>
			fields: Prisma.ProductCategoryFieldRefs
			operations: {
				findUnique: {
					args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
				}
				findFirst: {
					args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
				}
				findMany: {
					args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
				}
				create: {
					args: Prisma.ProductCategoryCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
				}
				createMany: {
					args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
				}
				update: {
					args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
				}
				deleteMany: {
					args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
				}
				aggregate: {
					args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateProductCategory>
				}
				groupBy: {
					args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ProductCategoryGroupByOutputType>[]
				}
				count: {
					args: Prisma.ProductCategoryCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ProductCategoryCountAggregateOutputType> | number
				}
			}
		}
		Product: {
			payload: Prisma.$ProductPayload<ExtArgs>
			fields: Prisma.ProductFieldRefs
			operations: {
				findUnique: {
					args: Prisma.ProductFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
				}
				findFirst: {
					args: Prisma.ProductFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
				}
				findMany: {
					args: Prisma.ProductFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>[]
				}
				create: {
					args: Prisma.ProductCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
				}
				createMany: {
					args: Prisma.ProductCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.ProductDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
				}
				update: {
					args: Prisma.ProductUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
				}
				deleteMany: {
					args: Prisma.ProductDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.ProductUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.ProductUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProductPayload>
				}
				aggregate: {
					args: Prisma.ProductAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateProduct>
				}
				groupBy: {
					args: Prisma.ProductGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ProductGroupByOutputType>[]
				}
				count: {
					args: Prisma.ProductCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ProductCountAggregateOutputType> | number
				}
			}
		}
		FinancialPerson: {
			payload: Prisma.$FinancialPersonPayload<ExtArgs>
			fields: Prisma.FinancialPersonFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialPersonFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialPersonFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>
				}
				findFirst: {
					args: Prisma.FinancialPersonFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialPersonFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>
				}
				findMany: {
					args: Prisma.FinancialPersonFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>[]
				}
				create: {
					args: Prisma.FinancialPersonCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>
				}
				createMany: {
					args: Prisma.FinancialPersonCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialPersonDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>
				}
				update: {
					args: Prisma.FinancialPersonUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>
				}
				deleteMany: {
					args: Prisma.FinancialPersonDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialPersonUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialPersonUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonPayload>
				}
				aggregate: {
					args: Prisma.FinancialPersonAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialPerson>
				}
				groupBy: {
					args: Prisma.FinancialPersonGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialPersonCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonCountAggregateOutputType> | number
				}
			}
		}
		FinancialPersonDataUser: {
			payload: Prisma.$FinancialPersonDataUserPayload<ExtArgs>
			fields: Prisma.FinancialPersonDataUserFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialPersonDataUserFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialPersonDataUserFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>
				}
				findFirst: {
					args: Prisma.FinancialPersonDataUserFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialPersonDataUserFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>
				}
				findMany: {
					args: Prisma.FinancialPersonDataUserFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>[]
				}
				create: {
					args: Prisma.FinancialPersonDataUserCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>
				}
				createMany: {
					args: Prisma.FinancialPersonDataUserCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialPersonDataUserDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>
				}
				update: {
					args: Prisma.FinancialPersonDataUserUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>
				}
				deleteMany: {
					args: Prisma.FinancialPersonDataUserDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialPersonDataUserUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialPersonDataUserUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataUserPayload>
				}
				aggregate: {
					args: Prisma.FinancialPersonDataUserAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialPersonDataUser>
				}
				groupBy: {
					args: Prisma.FinancialPersonDataUserGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataUserGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialPersonDataUserCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataUserCountAggregateOutputType> | number
				}
			}
		}
		FinancialGroup: {
			payload: Prisma.$FinancialGroupPayload<ExtArgs>
			fields: Prisma.FinancialGroupFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialGroupFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialGroupFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>
				}
				findFirst: {
					args: Prisma.FinancialGroupFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialGroupFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>
				}
				findMany: {
					args: Prisma.FinancialGroupFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>[]
				}
				create: {
					args: Prisma.FinancialGroupCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>
				}
				createMany: {
					args: Prisma.FinancialGroupCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialGroupDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>
				}
				update: {
					args: Prisma.FinancialGroupUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>
				}
				deleteMany: {
					args: Prisma.FinancialGroupDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialGroupUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialGroupUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPayload>
				}
				aggregate: {
					args: Prisma.FinancialGroupAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialGroup>
				}
				groupBy: {
					args: Prisma.FinancialGroupGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialGroupGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialGroupCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialGroupCountAggregateOutputType> | number
				}
			}
		}
		FinancialGroupPersonElement: {
			payload: Prisma.$FinancialGroupPersonElementPayload<ExtArgs>
			fields: Prisma.FinancialGroupPersonElementFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialGroupPersonElementFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialGroupPersonElementFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>
				}
				findFirst: {
					args: Prisma.FinancialGroupPersonElementFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialGroupPersonElementFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>
				}
				findMany: {
					args: Prisma.FinancialGroupPersonElementFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>[]
				}
				create: {
					args: Prisma.FinancialGroupPersonElementCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>
				}
				createMany: {
					args: Prisma.FinancialGroupPersonElementCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialGroupPersonElementDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>
				}
				update: {
					args: Prisma.FinancialGroupPersonElementUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>
				}
				deleteMany: {
					args: Prisma.FinancialGroupPersonElementDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialGroupPersonElementUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialGroupPersonElementUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialGroupPersonElementPayload>
				}
				aggregate: {
					args: Prisma.FinancialGroupPersonElementAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialGroupPersonElement>
				}
				groupBy: {
					args: Prisma.FinancialGroupPersonElementGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialGroupPersonElementGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialGroupPersonElementCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialGroupPersonElementCountAggregateOutputType> | number
				}
			}
		}
		FinancialPersonDataActivity: {
			payload: Prisma.$FinancialPersonDataActivityPayload<ExtArgs>
			fields: Prisma.FinancialPersonDataActivityFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialPersonDataActivityFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialPersonDataActivityFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>
				}
				findFirst: {
					args: Prisma.FinancialPersonDataActivityFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialPersonDataActivityFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>
				}
				findMany: {
					args: Prisma.FinancialPersonDataActivityFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>[]
				}
				create: {
					args: Prisma.FinancialPersonDataActivityCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>
				}
				createMany: {
					args: Prisma.FinancialPersonDataActivityCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialPersonDataActivityDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>
				}
				update: {
					args: Prisma.FinancialPersonDataActivityUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>
				}
				deleteMany: {
					args: Prisma.FinancialPersonDataActivityDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialPersonDataActivityUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialPersonDataActivityUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataActivityPayload>
				}
				aggregate: {
					args: Prisma.FinancialPersonDataActivityAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialPersonDataActivity>
				}
				groupBy: {
					args: Prisma.FinancialPersonDataActivityGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataActivityGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialPersonDataActivityCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataActivityCountAggregateOutputType> | number
				}
			}
		}
		FinancialPersonDataCommittee: {
			payload: Prisma.$FinancialPersonDataCommitteePayload<ExtArgs>
			fields: Prisma.FinancialPersonDataCommitteeFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialPersonDataCommitteeFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialPersonDataCommitteeFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>
				}
				findFirst: {
					args: Prisma.FinancialPersonDataCommitteeFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialPersonDataCommitteeFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>
				}
				findMany: {
					args: Prisma.FinancialPersonDataCommitteeFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>[]
				}
				create: {
					args: Prisma.FinancialPersonDataCommitteeCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>
				}
				createMany: {
					args: Prisma.FinancialPersonDataCommitteeCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialPersonDataCommitteeDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>
				}
				update: {
					args: Prisma.FinancialPersonDataCommitteeUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>
				}
				deleteMany: {
					args: Prisma.FinancialPersonDataCommitteeDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialPersonDataCommitteeUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialPersonDataCommitteeUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataCommitteePayload>
				}
				aggregate: {
					args: Prisma.FinancialPersonDataCommitteeAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialPersonDataCommittee>
				}
				groupBy: {
					args: Prisma.FinancialPersonDataCommitteeGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataCommitteeGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialPersonDataCommitteeCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataCommitteeCountAggregateOutputType> | number
				}
			}
		}
		FinancialPersonDataOther: {
			payload: Prisma.$FinancialPersonDataOtherPayload<ExtArgs>
			fields: Prisma.FinancialPersonDataOtherFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FinancialPersonDataOtherFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FinancialPersonDataOtherFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>
				}
				findFirst: {
					args: Prisma.FinancialPersonDataOtherFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FinancialPersonDataOtherFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>
				}
				findMany: {
					args: Prisma.FinancialPersonDataOtherFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>[]
				}
				create: {
					args: Prisma.FinancialPersonDataOtherCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>
				}
				createMany: {
					args: Prisma.FinancialPersonDataOtherCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FinancialPersonDataOtherDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>
				}
				update: {
					args: Prisma.FinancialPersonDataOtherUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>
				}
				deleteMany: {
					args: Prisma.FinancialPersonDataOtherDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FinancialPersonDataOtherUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FinancialPersonDataOtherUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialPersonDataOtherPayload>
				}
				aggregate: {
					args: Prisma.FinancialPersonDataOtherAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialPersonDataOther>
				}
				groupBy: {
					args: Prisma.FinancialPersonDataOtherGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataOtherGroupByOutputType>[]
				}
				count: {
					args: Prisma.FinancialPersonDataOtherCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FinancialPersonDataOtherCountAggregateOutputType> | number
				}
			}
		}
		Transaction: {
			payload: Prisma.$TransactionPayload<ExtArgs>
			fields: Prisma.TransactionFieldRefs
			operations: {
				findUnique: {
					args: Prisma.TransactionFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
				}
				findFirst: {
					args: Prisma.TransactionFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
				}
				findMany: {
					args: Prisma.TransactionFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
				}
				create: {
					args: Prisma.TransactionCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
				}
				createMany: {
					args: Prisma.TransactionCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.TransactionDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
				}
				update: {
					args: Prisma.TransactionUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
				}
				deleteMany: {
					args: Prisma.TransactionDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.TransactionUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.TransactionUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
				}
				aggregate: {
					args: Prisma.TransactionAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
				}
				groupBy: {
					args: Prisma.TransactionGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
				}
				count: {
					args: Prisma.TransactionCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
				}
			}
		}
		TransactionMatchRow: {
			payload: Prisma.$TransactionMatchRowPayload<ExtArgs>
			fields: Prisma.TransactionMatchRowFieldRefs
			operations: {
				findUnique: {
					args: Prisma.TransactionMatchRowFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.TransactionMatchRowFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>
				}
				findFirst: {
					args: Prisma.TransactionMatchRowFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.TransactionMatchRowFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>
				}
				findMany: {
					args: Prisma.TransactionMatchRowFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>[]
				}
				create: {
					args: Prisma.TransactionMatchRowCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>
				}
				createMany: {
					args: Prisma.TransactionMatchRowCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.TransactionMatchRowDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>
				}
				update: {
					args: Prisma.TransactionMatchRowUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>
				}
				deleteMany: {
					args: Prisma.TransactionMatchRowDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.TransactionMatchRowUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.TransactionMatchRowUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionMatchRowPayload>
				}
				aggregate: {
					args: Prisma.TransactionMatchRowAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateTransactionMatchRow>
				}
				groupBy: {
					args: Prisma.TransactionMatchRowGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TransactionMatchRowGroupByOutputType>[]
				}
				count: {
					args: Prisma.TransactionMatchRowCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TransactionMatchRowCountAggregateOutputType> | number
				}
			}
		}
		SaldoTransaction: {
			payload: Prisma.$SaldoTransactionPayload<ExtArgs>
			fields: Prisma.SaldoTransactionFieldRefs
			operations: {
				findUnique: {
					args: Prisma.SaldoTransactionFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.SaldoTransactionFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>
				}
				findFirst: {
					args: Prisma.SaldoTransactionFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.SaldoTransactionFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>
				}
				findMany: {
					args: Prisma.SaldoTransactionFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>[]
				}
				create: {
					args: Prisma.SaldoTransactionCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>
				}
				createMany: {
					args: Prisma.SaldoTransactionCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.SaldoTransactionDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>
				}
				update: {
					args: Prisma.SaldoTransactionUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>
				}
				deleteMany: {
					args: Prisma.SaldoTransactionDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.SaldoTransactionUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.SaldoTransactionUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SaldoTransactionPayload>
				}
				aggregate: {
					args: Prisma.SaldoTransactionAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateSaldoTransaction>
				}
				groupBy: {
					args: Prisma.SaldoTransactionGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.SaldoTransactionGroupByOutputType>[]
				}
				count: {
					args: Prisma.SaldoTransactionCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.SaldoTransactionCountAggregateOutputType> | number
				}
			}
		}
		BankTransaction: {
			payload: Prisma.$BankTransactionPayload<ExtArgs>
			fields: Prisma.BankTransactionFieldRefs
			operations: {
				findUnique: {
					args: Prisma.BankTransactionFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.BankTransactionFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
				}
				findFirst: {
					args: Prisma.BankTransactionFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.BankTransactionFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
				}
				findMany: {
					args: Prisma.BankTransactionFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
				}
				create: {
					args: Prisma.BankTransactionCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
				}
				createMany: {
					args: Prisma.BankTransactionCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.BankTransactionDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
				}
				update: {
					args: Prisma.BankTransactionUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
				}
				deleteMany: {
					args: Prisma.BankTransactionDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.BankTransactionUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.BankTransactionUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$BankTransactionPayload>
				}
				aggregate: {
					args: Prisma.BankTransactionAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateBankTransaction>
				}
				groupBy: {
					args: Prisma.BankTransactionGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.BankTransactionGroupByOutputType>[]
				}
				count: {
					args: Prisma.BankTransactionCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.BankTransactionCountAggregateOutputType> | number
				}
			}
		}
		Streeplijst: {
			payload: Prisma.$StreeplijstPayload<ExtArgs>
			fields: Prisma.StreeplijstFieldRefs
			operations: {
				findUnique: {
					args: Prisma.StreeplijstFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.StreeplijstFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>
				}
				findFirst: {
					args: Prisma.StreeplijstFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.StreeplijstFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>
				}
				findMany: {
					args: Prisma.StreeplijstFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>[]
				}
				create: {
					args: Prisma.StreeplijstCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>
				}
				createMany: {
					args: Prisma.StreeplijstCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.StreeplijstDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>
				}
				update: {
					args: Prisma.StreeplijstUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>
				}
				deleteMany: {
					args: Prisma.StreeplijstDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.StreeplijstUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.StreeplijstUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$StreeplijstPayload>
				}
				aggregate: {
					args: Prisma.StreeplijstAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateStreeplijst>
				}
				groupBy: {
					args: Prisma.StreeplijstGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.StreeplijstGroupByOutputType>[]
				}
				count: {
					args: Prisma.StreeplijstCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.StreeplijstCountAggregateOutputType> | number
				}
			}
		}
		Journal: {
			payload: Prisma.$JournalPayload<ExtArgs>
			fields: Prisma.JournalFieldRefs
			operations: {
				findUnique: {
					args: Prisma.JournalFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>
				}
				findFirst: {
					args: Prisma.JournalFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>
				}
				findMany: {
					args: Prisma.JournalFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>[]
				}
				create: {
					args: Prisma.JournalCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>
				}
				createMany: {
					args: Prisma.JournalCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.JournalDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>
				}
				update: {
					args: Prisma.JournalUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>
				}
				deleteMany: {
					args: Prisma.JournalDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.JournalUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.JournalUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalPayload>
				}
				aggregate: {
					args: Prisma.JournalAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateJournal>
				}
				groupBy: {
					args: Prisma.JournalGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.JournalGroupByOutputType>[]
				}
				count: {
					args: Prisma.JournalCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.JournalCountAggregateOutputType> | number
				}
			}
		}
		DeclarationData: {
			payload: Prisma.$DeclarationDataPayload<ExtArgs>
			fields: Prisma.DeclarationDataFieldRefs
			operations: {
				findUnique: {
					args: Prisma.DeclarationDataFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.DeclarationDataFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>
				}
				findFirst: {
					args: Prisma.DeclarationDataFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.DeclarationDataFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>
				}
				findMany: {
					args: Prisma.DeclarationDataFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>[]
				}
				create: {
					args: Prisma.DeclarationDataCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>
				}
				createMany: {
					args: Prisma.DeclarationDataCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.DeclarationDataDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>
				}
				update: {
					args: Prisma.DeclarationDataUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>
				}
				deleteMany: {
					args: Prisma.DeclarationDataDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.DeclarationDataUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.DeclarationDataUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$DeclarationDataPayload>
				}
				aggregate: {
					args: Prisma.DeclarationDataAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateDeclarationData>
				}
				groupBy: {
					args: Prisma.DeclarationDataGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.DeclarationDataGroupByOutputType>[]
				}
				count: {
					args: Prisma.DeclarationDataCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.DeclarationDataCountAggregateOutputType> | number
				}
			}
		}
		JournalRow: {
			payload: Prisma.$JournalRowPayload<ExtArgs>
			fields: Prisma.JournalRowFieldRefs
			operations: {
				findUnique: {
					args: Prisma.JournalRowFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.JournalRowFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>
				}
				findFirst: {
					args: Prisma.JournalRowFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.JournalRowFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>
				}
				findMany: {
					args: Prisma.JournalRowFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>[]
				}
				create: {
					args: Prisma.JournalRowCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>
				}
				createMany: {
					args: Prisma.JournalRowCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.JournalRowDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>
				}
				update: {
					args: Prisma.JournalRowUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>
				}
				deleteMany: {
					args: Prisma.JournalRowDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.JournalRowUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.JournalRowUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalRowPayload>
				}
				aggregate: {
					args: Prisma.JournalRowAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateJournalRow>
				}
				groupBy: {
					args: Prisma.JournalRowGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.JournalRowGroupByOutputType>[]
				}
				count: {
					args: Prisma.JournalRowCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.JournalRowCountAggregateOutputType> | number
				}
			}
		}
		Link: {
			payload: Prisma.$LinkPayload<ExtArgs>
			fields: Prisma.LinkFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LinkFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LinkFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
				}
				findFirst: {
					args: Prisma.LinkFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LinkFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
				}
				findMany: {
					args: Prisma.LinkFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>[]
				}
				create: {
					args: Prisma.LinkCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
				}
				createMany: {
					args: Prisma.LinkCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LinkDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
				}
				update: {
					args: Prisma.LinkUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
				}
				deleteMany: {
					args: Prisma.LinkDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LinkUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LinkUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
				}
				aggregate: {
					args: Prisma.LinkAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLink>
				}
				groupBy: {
					args: Prisma.LinkGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LinkGroupByOutputType>[]
				}
				count: {
					args: Prisma.LinkCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LinkCountAggregateOutputType> | number
				}
			}
		}
		LinkClick: {
			payload: Prisma.$LinkClickPayload<ExtArgs>
			fields: Prisma.LinkClickFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LinkClickFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LinkClickFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>
				}
				findFirst: {
					args: Prisma.LinkClickFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LinkClickFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>
				}
				findMany: {
					args: Prisma.LinkClickFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>[]
				}
				create: {
					args: Prisma.LinkClickCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>
				}
				createMany: {
					args: Prisma.LinkClickCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LinkClickDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>
				}
				update: {
					args: Prisma.LinkClickUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>
				}
				deleteMany: {
					args: Prisma.LinkClickDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LinkClickUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LinkClickUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkClickPayload>
				}
				aggregate: {
					args: Prisma.LinkClickAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLinkClick>
				}
				groupBy: {
					args: Prisma.LinkClickGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LinkClickGroupByOutputType>[]
				}
				count: {
					args: Prisma.LinkClickCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LinkClickCountAggregateOutputType> | number
				}
			}
		}
		EmailAlias: {
			payload: Prisma.$EmailAliasPayload<ExtArgs>
			fields: Prisma.EmailAliasFieldRefs
			operations: {
				findUnique: {
					args: Prisma.EmailAliasFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.EmailAliasFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>
				}
				findFirst: {
					args: Prisma.EmailAliasFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.EmailAliasFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>
				}
				findMany: {
					args: Prisma.EmailAliasFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>[]
				}
				create: {
					args: Prisma.EmailAliasCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>
				}
				createMany: {
					args: Prisma.EmailAliasCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.EmailAliasDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>
				}
				update: {
					args: Prisma.EmailAliasUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>
				}
				deleteMany: {
					args: Prisma.EmailAliasDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.EmailAliasUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.EmailAliasUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasPayload>
				}
				aggregate: {
					args: Prisma.EmailAliasAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateEmailAlias>
				}
				groupBy: {
					args: Prisma.EmailAliasGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailAliasGroupByOutputType>[]
				}
				count: {
					args: Prisma.EmailAliasCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailAliasCountAggregateOutputType> | number
				}
			}
		}
		EmailAliasCommittee: {
			payload: Prisma.$EmailAliasCommitteePayload<ExtArgs>
			fields: Prisma.EmailAliasCommitteeFieldRefs
			operations: {
				findUnique: {
					args: Prisma.EmailAliasCommitteeFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.EmailAliasCommitteeFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>
				}
				findFirst: {
					args: Prisma.EmailAliasCommitteeFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.EmailAliasCommitteeFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>
				}
				findMany: {
					args: Prisma.EmailAliasCommitteeFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>[]
				}
				create: {
					args: Prisma.EmailAliasCommitteeCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>
				}
				createMany: {
					args: Prisma.EmailAliasCommitteeCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.EmailAliasCommitteeDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>
				}
				update: {
					args: Prisma.EmailAliasCommitteeUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>
				}
				deleteMany: {
					args: Prisma.EmailAliasCommitteeDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.EmailAliasCommitteeUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.EmailAliasCommitteeUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasCommitteePayload>
				}
				aggregate: {
					args: Prisma.EmailAliasCommitteeAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateEmailAliasCommittee>
				}
				groupBy: {
					args: Prisma.EmailAliasCommitteeGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailAliasCommitteeGroupByOutputType>[]
				}
				count: {
					args: Prisma.EmailAliasCommitteeCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailAliasCommitteeCountAggregateOutputType> | number
				}
			}
		}
		EmailAliasUser: {
			payload: Prisma.$EmailAliasUserPayload<ExtArgs>
			fields: Prisma.EmailAliasUserFieldRefs
			operations: {
				findUnique: {
					args: Prisma.EmailAliasUserFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.EmailAliasUserFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>
				}
				findFirst: {
					args: Prisma.EmailAliasUserFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.EmailAliasUserFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>
				}
				findMany: {
					args: Prisma.EmailAliasUserFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>[]
				}
				create: {
					args: Prisma.EmailAliasUserCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>
				}
				createMany: {
					args: Prisma.EmailAliasUserCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.EmailAliasUserDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>
				}
				update: {
					args: Prisma.EmailAliasUserUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>
				}
				deleteMany: {
					args: Prisma.EmailAliasUserDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.EmailAliasUserUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.EmailAliasUserUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailAliasUserPayload>
				}
				aggregate: {
					args: Prisma.EmailAliasUserAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateEmailAliasUser>
				}
				groupBy: {
					args: Prisma.EmailAliasUserGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailAliasUserGroupByOutputType>[]
				}
				count: {
					args: Prisma.EmailAliasUserCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailAliasUserCountAggregateOutputType> | number
				}
			}
		}
		EmailContact: {
			payload: Prisma.$EmailContactPayload<ExtArgs>
			fields: Prisma.EmailContactFieldRefs
			operations: {
				findUnique: {
					args: Prisma.EmailContactFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.EmailContactFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>
				}
				findFirst: {
					args: Prisma.EmailContactFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.EmailContactFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>
				}
				findMany: {
					args: Prisma.EmailContactFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>[]
				}
				create: {
					args: Prisma.EmailContactCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>
				}
				createMany: {
					args: Prisma.EmailContactCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.EmailContactDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>
				}
				update: {
					args: Prisma.EmailContactUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>
				}
				deleteMany: {
					args: Prisma.EmailContactDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.EmailContactUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.EmailContactUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailContactPayload>
				}
				aggregate: {
					args: Prisma.EmailContactAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateEmailContact>
				}
				groupBy: {
					args: Prisma.EmailContactGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailContactGroupByOutputType>[]
				}
				count: {
					args: Prisma.EmailContactCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.EmailContactCountAggregateOutputType> | number
				}
			}
		}
		ClickSession: {
			payload: Prisma.$ClickSessionPayload<ExtArgs>
			fields: Prisma.ClickSessionFieldRefs
			operations: {
				findUnique: {
					args: Prisma.ClickSessionFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.ClickSessionFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>
				}
				findFirst: {
					args: Prisma.ClickSessionFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.ClickSessionFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>
				}
				findMany: {
					args: Prisma.ClickSessionFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>[]
				}
				create: {
					args: Prisma.ClickSessionCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>
				}
				createMany: {
					args: Prisma.ClickSessionCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.ClickSessionDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>
				}
				update: {
					args: Prisma.ClickSessionUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>
				}
				deleteMany: {
					args: Prisma.ClickSessionDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.ClickSessionUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.ClickSessionUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ClickSessionPayload>
				}
				aggregate: {
					args: Prisma.ClickSessionAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateClickSession>
				}
				groupBy: {
					args: Prisma.ClickSessionGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ClickSessionGroupByOutputType>[]
				}
				count: {
					args: Prisma.ClickSessionCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.ClickSessionCountAggregateOutputType> | number
				}
			}
		}
		Track: {
			payload: Prisma.$TrackPayload<ExtArgs>
			fields: Prisma.TrackFieldRefs
			operations: {
				findUnique: {
					args: Prisma.TrackFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.TrackFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>
				}
				findFirst: {
					args: Prisma.TrackFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.TrackFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>
				}
				findMany: {
					args: Prisma.TrackFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>[]
				}
				create: {
					args: Prisma.TrackCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>
				}
				createMany: {
					args: Prisma.TrackCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.TrackDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>
				}
				update: {
					args: Prisma.TrackUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>
				}
				deleteMany: {
					args: Prisma.TrackDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.TrackUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.TrackUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackPayload>
				}
				aggregate: {
					args: Prisma.TrackAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateTrack>
				}
				groupBy: {
					args: Prisma.TrackGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TrackGroupByOutputType>[]
				}
				count: {
					args: Prisma.TrackCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TrackCountAggregateOutputType> | number
				}
			}
		}
		TrackReaction: {
			payload: Prisma.$TrackReactionPayload<ExtArgs>
			fields: Prisma.TrackReactionFieldRefs
			operations: {
				findUnique: {
					args: Prisma.TrackReactionFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.TrackReactionFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>
				}
				findFirst: {
					args: Prisma.TrackReactionFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.TrackReactionFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>
				}
				findMany: {
					args: Prisma.TrackReactionFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>[]
				}
				create: {
					args: Prisma.TrackReactionCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>
				}
				createMany: {
					args: Prisma.TrackReactionCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.TrackReactionDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>
				}
				update: {
					args: Prisma.TrackReactionUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>
				}
				deleteMany: {
					args: Prisma.TrackReactionDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.TrackReactionUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.TrackReactionUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TrackReactionPayload>
				}
				aggregate: {
					args: Prisma.TrackReactionAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateTrackReaction>
				}
				groupBy: {
					args: Prisma.TrackReactionGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TrackReactionGroupByOutputType>[]
				}
				count: {
					args: Prisma.TrackReactionCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.TrackReactionCountAggregateOutputType> | number
				}
			}
		}
		Photo: {
			payload: Prisma.$PhotoPayload<ExtArgs>
			fields: Prisma.PhotoFieldRefs
			operations: {
				findUnique: {
					args: Prisma.PhotoFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>
				}
				findFirst: {
					args: Prisma.PhotoFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>
				}
				findMany: {
					args: Prisma.PhotoFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>[]
				}
				create: {
					args: Prisma.PhotoCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>
				}
				createMany: {
					args: Prisma.PhotoCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.PhotoDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>
				}
				update: {
					args: Prisma.PhotoUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>
				}
				deleteMany: {
					args: Prisma.PhotoDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.PhotoUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.PhotoUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPayload>
				}
				aggregate: {
					args: Prisma.PhotoAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregatePhoto>
				}
				groupBy: {
					args: Prisma.PhotoGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoGroupByOutputType>[]
				}
				count: {
					args: Prisma.PhotoCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoCountAggregateOutputType> | number
				}
			}
		}
		PhotoTag: {
			payload: Prisma.$PhotoTagPayload<ExtArgs>
			fields: Prisma.PhotoTagFieldRefs
			operations: {
				findUnique: {
					args: Prisma.PhotoTagFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.PhotoTagFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>
				}
				findFirst: {
					args: Prisma.PhotoTagFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.PhotoTagFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>
				}
				findMany: {
					args: Prisma.PhotoTagFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>[]
				}
				create: {
					args: Prisma.PhotoTagCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>
				}
				createMany: {
					args: Prisma.PhotoTagCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.PhotoTagDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>
				}
				update: {
					args: Prisma.PhotoTagUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>
				}
				deleteMany: {
					args: Prisma.PhotoTagDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.PhotoTagUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.PhotoTagUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoTagPayload>
				}
				aggregate: {
					args: Prisma.PhotoTagAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregatePhotoTag>
				}
				groupBy: {
					args: Prisma.PhotoTagGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoTagGroupByOutputType>[]
				}
				count: {
					args: Prisma.PhotoTagCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoTagCountAggregateOutputType> | number
				}
			}
		}
		PhotosWithTags: {
			payload: Prisma.$PhotosWithTagsPayload<ExtArgs>
			fields: Prisma.PhotosWithTagsFieldRefs
			operations: {
				findUnique: {
					args: Prisma.PhotosWithTagsFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.PhotosWithTagsFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>
				}
				findFirst: {
					args: Prisma.PhotosWithTagsFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.PhotosWithTagsFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>
				}
				findMany: {
					args: Prisma.PhotosWithTagsFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>[]
				}
				create: {
					args: Prisma.PhotosWithTagsCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>
				}
				createMany: {
					args: Prisma.PhotosWithTagsCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.PhotosWithTagsDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>
				}
				update: {
					args: Prisma.PhotosWithTagsUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>
				}
				deleteMany: {
					args: Prisma.PhotosWithTagsDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.PhotosWithTagsUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.PhotosWithTagsUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotosWithTagsPayload>
				}
				aggregate: {
					args: Prisma.PhotosWithTagsAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregatePhotosWithTags>
				}
				groupBy: {
					args: Prisma.PhotosWithTagsGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotosWithTagsGroupByOutputType>[]
				}
				count: {
					args: Prisma.PhotosWithTagsCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotosWithTagsCountAggregateOutputType> | number
				}
			}
		}
		PhotoPersonTag: {
			payload: Prisma.$PhotoPersonTagPayload<ExtArgs>
			fields: Prisma.PhotoPersonTagFieldRefs
			operations: {
				findUnique: {
					args: Prisma.PhotoPersonTagFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.PhotoPersonTagFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>
				}
				findFirst: {
					args: Prisma.PhotoPersonTagFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.PhotoPersonTagFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>
				}
				findMany: {
					args: Prisma.PhotoPersonTagFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>[]
				}
				create: {
					args: Prisma.PhotoPersonTagCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>
				}
				createMany: {
					args: Prisma.PhotoPersonTagCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.PhotoPersonTagDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>
				}
				update: {
					args: Prisma.PhotoPersonTagUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>
				}
				deleteMany: {
					args: Prisma.PhotoPersonTagDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.PhotoPersonTagUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.PhotoPersonTagUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoPersonTagPayload>
				}
				aggregate: {
					args: Prisma.PhotoPersonTagAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregatePhotoPersonTag>
				}
				groupBy: {
					args: Prisma.PhotoPersonTagGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoPersonTagGroupByOutputType>[]
				}
				count: {
					args: Prisma.PhotoPersonTagCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoPersonTagCountAggregateOutputType> | number
				}
			}
		}
		PhotoRating: {
			payload: Prisma.$PhotoRatingPayload<ExtArgs>
			fields: Prisma.PhotoRatingFieldRefs
			operations: {
				findUnique: {
					args: Prisma.PhotoRatingFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.PhotoRatingFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>
				}
				findFirst: {
					args: Prisma.PhotoRatingFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.PhotoRatingFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>
				}
				findMany: {
					args: Prisma.PhotoRatingFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>[]
				}
				create: {
					args: Prisma.PhotoRatingCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>
				}
				createMany: {
					args: Prisma.PhotoRatingCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.PhotoRatingDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>
				}
				update: {
					args: Prisma.PhotoRatingUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>
				}
				deleteMany: {
					args: Prisma.PhotoRatingDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.PhotoRatingUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.PhotoRatingUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PhotoRatingPayload>
				}
				aggregate: {
					args: Prisma.PhotoRatingAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregatePhotoRating>
				}
				groupBy: {
					args: Prisma.PhotoRatingGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoRatingGroupByOutputType>[]
				}
				count: {
					args: Prisma.PhotoRatingCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.PhotoRatingCountAggregateOutputType> | number
				}
			}
		}
		Comment: {
			payload: Prisma.$CommentPayload<ExtArgs>
			fields: Prisma.CommentFieldRefs
			operations: {
				findUnique: {
					args: Prisma.CommentFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
				}
				findFirst: {
					args: Prisma.CommentFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
				}
				findMany: {
					args: Prisma.CommentFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
				}
				create: {
					args: Prisma.CommentCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
				}
				createMany: {
					args: Prisma.CommentCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.CommentDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
				}
				update: {
					args: Prisma.CommentUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
				}
				deleteMany: {
					args: Prisma.CommentDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.CommentUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.CommentUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
				}
				aggregate: {
					args: Prisma.CommentAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
				}
				groupBy: {
					args: Prisma.CommentGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
				}
				count: {
					args: Prisma.CommentCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
				}
			}
		}
		Leaderboard: {
			payload: Prisma.$LeaderboardPayload<ExtArgs>
			fields: Prisma.LeaderboardFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>
				}
				findFirst: {
					args: Prisma.LeaderboardFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>
				}
				findMany: {
					args: Prisma.LeaderboardFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
				}
				create: {
					args: Prisma.LeaderboardCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>
				}
				createMany: {
					args: Prisma.LeaderboardCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LeaderboardDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>
				}
				update: {
					args: Prisma.LeaderboardUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>
				}
				deleteMany: {
					args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LeaderboardUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardPayload>
				}
				aggregate: {
					args: Prisma.LeaderboardAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLeaderboard>
				}
				groupBy: {
					args: Prisma.LeaderboardGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardGroupByOutputType>[]
				}
				count: {
					args: Prisma.LeaderboardCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardCountAggregateOutputType> | number
				}
			}
		}
		LeaderboardEntry: {
			payload: Prisma.$LeaderboardEntryPayload<ExtArgs>
			fields: Prisma.LeaderboardEntryFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LeaderboardEntryFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LeaderboardEntryFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
				}
				findFirst: {
					args: Prisma.LeaderboardEntryFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LeaderboardEntryFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
				}
				findMany: {
					args: Prisma.LeaderboardEntryFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>[]
				}
				create: {
					args: Prisma.LeaderboardEntryCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
				}
				createMany: {
					args: Prisma.LeaderboardEntryCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LeaderboardEntryDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
				}
				update: {
					args: Prisma.LeaderboardEntryUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
				}
				deleteMany: {
					args: Prisma.LeaderboardEntryDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LeaderboardEntryUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LeaderboardEntryUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardEntryPayload>
				}
				aggregate: {
					args: Prisma.LeaderboardEntryAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLeaderboardEntry>
				}
				groupBy: {
					args: Prisma.LeaderboardEntryGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardEntryGroupByOutputType>[]
				}
				count: {
					args: Prisma.LeaderboardEntryCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardEntryCountAggregateOutputType> | number
				}
			}
		}
		LeaderboardChallenger: {
			payload: Prisma.$LeaderboardChallengerPayload<ExtArgs>
			fields: Prisma.LeaderboardChallengerFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LeaderboardChallengerFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LeaderboardChallengerFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>
				}
				findFirst: {
					args: Prisma.LeaderboardChallengerFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LeaderboardChallengerFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>
				}
				findMany: {
					args: Prisma.LeaderboardChallengerFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>[]
				}
				create: {
					args: Prisma.LeaderboardChallengerCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>
				}
				createMany: {
					args: Prisma.LeaderboardChallengerCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LeaderboardChallengerDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>
				}
				update: {
					args: Prisma.LeaderboardChallengerUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>
				}
				deleteMany: {
					args: Prisma.LeaderboardChallengerDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LeaderboardChallengerUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LeaderboardChallengerUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerPayload>
				}
				aggregate: {
					args: Prisma.LeaderboardChallengerAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLeaderboardChallenger>
				}
				groupBy: {
					args: Prisma.LeaderboardChallengerGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardChallengerGroupByOutputType>[]
				}
				count: {
					args: Prisma.LeaderboardChallengerCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardChallengerCountAggregateOutputType> | number
				}
			}
		}
		LeaderboardChallengerUser: {
			payload: Prisma.$LeaderboardChallengerUserPayload<ExtArgs>
			fields: Prisma.LeaderboardChallengerUserFieldRefs
			operations: {
				findUnique: {
					args: Prisma.LeaderboardChallengerUserFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.LeaderboardChallengerUserFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>
				}
				findFirst: {
					args: Prisma.LeaderboardChallengerUserFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.LeaderboardChallengerUserFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>
				}
				findMany: {
					args: Prisma.LeaderboardChallengerUserFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>[]
				}
				create: {
					args: Prisma.LeaderboardChallengerUserCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>
				}
				createMany: {
					args: Prisma.LeaderboardChallengerUserCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.LeaderboardChallengerUserDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>
				}
				update: {
					args: Prisma.LeaderboardChallengerUserUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>
				}
				deleteMany: {
					args: Prisma.LeaderboardChallengerUserDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.LeaderboardChallengerUserUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.LeaderboardChallengerUserUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaderboardChallengerUserPayload>
				}
				aggregate: {
					args: Prisma.LeaderboardChallengerUserAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateLeaderboardChallengerUser>
				}
				groupBy: {
					args: Prisma.LeaderboardChallengerUserGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardChallengerUserGroupByOutputType>[]
				}
				count: {
					args: Prisma.LeaderboardChallengerUserCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.LeaderboardChallengerUserCountAggregateOutputType> | number
				}
			}
		}
		File: {
			payload: Prisma.$FilePayload<ExtArgs>
			fields: Prisma.FileFieldRefs
			operations: {
				findUnique: {
					args: Prisma.FileFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
				}
				findFirst: {
					args: Prisma.FileFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
				}
				findMany: {
					args: Prisma.FileFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[]
				}
				create: {
					args: Prisma.FileCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
				}
				createMany: {
					args: Prisma.FileCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.FileDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
				}
				update: {
					args: Prisma.FileUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
				}
				deleteMany: {
					args: Prisma.FileDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.FileUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.FileUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>
				}
				aggregate: {
					args: Prisma.FileAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateFile>
				}
				groupBy: {
					args: Prisma.FileGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FileGroupByOutputType>[]
				}
				count: {
					args: Prisma.FileCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.FileCountAggregateOutputType> | number
				}
			}
		}
		Job: {
			payload: Prisma.$JobPayload<ExtArgs>
			fields: Prisma.JobFieldRefs
			operations: {
				findUnique: {
					args: Prisma.JobFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
				}
				findFirst: {
					args: Prisma.JobFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
				}
				findMany: {
					args: Prisma.JobFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>[]
				}
				create: {
					args: Prisma.JobCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
				}
				createMany: {
					args: Prisma.JobCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.JobDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
				}
				update: {
					args: Prisma.JobUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
				}
				deleteMany: {
					args: Prisma.JobDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.JobUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.JobUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$JobPayload>
				}
				aggregate: {
					args: Prisma.JobAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateJob>
				}
				groupBy: {
					args: Prisma.JobGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.JobGroupByOutputType>[]
				}
				count: {
					args: Prisma.JobCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.JobCountAggregateOutputType> | number
				}
			}
		}
		Notification: {
			payload: Prisma.$NotificationPayload<ExtArgs>
			fields: Prisma.NotificationFieldRefs
			operations: {
				findUnique: {
					args: Prisma.NotificationFindUniqueArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
				}
				findUniqueOrThrow: {
					args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
				}
				findFirst: {
					args: Prisma.NotificationFindFirstArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
				}
				findFirstOrThrow: {
					args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
				}
				findMany: {
					args: Prisma.NotificationFindManyArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
				}
				create: {
					args: Prisma.NotificationCreateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
				}
				createMany: {
					args: Prisma.NotificationCreateManyArgs<ExtArgs>
					result: BatchPayload
				}
				delete: {
					args: Prisma.NotificationDeleteArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
				}
				update: {
					args: Prisma.NotificationUpdateArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
				}
				deleteMany: {
					args: Prisma.NotificationDeleteManyArgs<ExtArgs>
					result: BatchPayload
				}
				updateMany: {
					args: Prisma.NotificationUpdateManyArgs<ExtArgs>
					result: BatchPayload
				}
				upsert: {
					args: Prisma.NotificationUpsertArgs<ExtArgs>
					result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
				}
				aggregate: {
					args: Prisma.NotificationAggregateArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
				}
				groupBy: {
					args: Prisma.NotificationGroupByArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
				}
				count: {
					args: Prisma.NotificationCountArgs<ExtArgs>
					result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
				}
			}
		}
	}
} & {
	other: {
		payload: any
		operations: {
			$executeRaw: {
				args: [query: TemplateStringsArray | Sql, ...values: any[]]
				result: any
			}
			$executeRawUnsafe: {
				args: [query: string, ...values: any[]]
				result: any
			}
			$queryRaw: {
				args: [query: TemplateStringsArray | Sql, ...values: any[]]
				result: any
			}
			$queryRawUnsafe: {
				args: [query: string, ...values: any[]]
				result: any
			}
		}
	}
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
	ReadUncommitted: 'ReadUncommitted',
	ReadCommitted: 'ReadCommitted',
	RepeatableRead: 'RepeatableRead',
	Serializable: 'Serializable',
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]

export const SettingsScalarFieldEnum = {
	id: 'id',
	name: 'name',
	description: 'description',
	value: 'value',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
} as const

export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]

export const BasePreferenceScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	key: 'key',
	defaultValue: 'defaultValue',
	description: 'description',
} as const

export type BasePreferenceScalarFieldEnum = (typeof BasePreferenceScalarFieldEnum)[keyof typeof BasePreferenceScalarFieldEnum]

export const PreferenceScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	userId: 'userId',
	baseId: 'baseId',
	value: 'value',
} as const

export type PreferenceScalarFieldEnum = (typeof PreferenceScalarFieldEnum)[keyof typeof PreferenceScalarFieldEnum]

export const UserScalarFieldEnum = {
	id: 'id',
	isActive: 'isActive',
	firstName: 'firstName',
	lastName: 'lastName',
	ldapId: 'ldapId',
	email: 'email',
	personalEmail: 'personalEmail',
	nickname: 'nickname',
	profilePicture: 'profilePicture',
	birthDate: 'birthDate',
	phone: 'phone',
	firstDrink: 'firstDrink',
	becameFeut: 'becameFeut',
	becameMember: 'becameMember',
	lastLoggedin: 'lastLoggedin',
	preferredTheme: 'preferredTheme',
	accessDisabled: 'accessDisabled',
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]

export const AccountScalarFieldEnum = {
	id: 'id',
	userId: 'userId',
	type: 'type',
	provider: 'provider',
	providerAccountId: 'providerAccountId',
	refresh_token: 'refresh_token',
	access_token: 'access_token',
	expires_at: 'expires_at',
	token_type: 'token_type',
	scope: 'scope',
	id_token: 'id_token',
	session_state: 'session_state',
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]

export const UnlinkedAccountScalarFieldEnum = {
	id: 'id',
	providerAccountId: 'providerAccountId',
	createdAt: 'createdAt',
} as const

export type UnlinkedAccountScalarFieldEnum = (typeof UnlinkedAccountScalarFieldEnum)[keyof typeof UnlinkedAccountScalarFieldEnum]

export const SessionScalarFieldEnum = {
	id: 'id',
	sessionToken: 'sessionToken',
	userId: 'userId',
	expires: 'expires',
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]

export const AccessTokenScalarFieldEnum = {
	token: 'token',
	name: 'name',
	type: 'type',
	userId: 'userId',
	lastUsed: 'lastUsed',
} as const

export type AccessTokenScalarFieldEnum = (typeof AccessTokenScalarFieldEnum)[keyof typeof AccessTokenScalarFieldEnum]

export const CommitteeScalarFieldEnum = {
	id: 'id',
	name: 'name',
	ldapId: 'ldapId',
	isActive: 'isActive',
} as const

export type CommitteeScalarFieldEnum = (typeof CommitteeScalarFieldEnum)[keyof typeof CommitteeScalarFieldEnum]

export const CommitteeMemberScalarFieldEnum = {
	id: 'id',
	committeeId: 'committeeId',
	userId: 'userId',
	joinDate: 'joinDate',
	leaveDate: 'leaveDate',
	function: 'function',
} as const

export type CommitteeMemberScalarFieldEnum = (typeof CommitteeMemberScalarFieldEnum)[keyof typeof CommitteeMemberScalarFieldEnum]

export const StrafbakScalarFieldEnum = {
	id: 'id',
	giverId: 'giverId',
	receiverId: 'receiverId',
	reason: 'reason',
	dateCreated: 'dateCreated',
	dateDeleted: 'dateDeleted',
	location: 'location',
} as const

export type StrafbakScalarFieldEnum = (typeof StrafbakScalarFieldEnum)[keyof typeof StrafbakScalarFieldEnum]

export const MaluspuntScalarFieldEnum = {
	id: 'id',
	giverId: 'giverId',
	receiverId: 'receiverId',
	reason: 'reason',
	dateCreated: 'dateCreated',
	amount: 'amount',
} as const

export type MaluspuntScalarFieldEnum = (typeof MaluspuntScalarFieldEnum)[keyof typeof MaluspuntScalarFieldEnum]

export const ActivityScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	createdById: 'createdById',
	name: 'name',
	description: 'description',
	startTime: 'startTime',
	endTime: 'endTime',
	locationId: 'locationId',
	membersOnly: 'membersOnly',
	committeeId: 'committeeId',
	photo: 'photo',
	url: 'url',
	isActive: 'isActive',
} as const

export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]

export const ActivityLocationScalarFieldEnum = {
	id: 'id',
	name: 'name',
	adress: 'adress',
	country: 'country',
	postalCode: 'postalCode',
	city: 'city',
	description: 'description',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	isActive: 'isActive',
} as const

export type ActivityLocationScalarFieldEnum = (typeof ActivityLocationScalarFieldEnum)[keyof typeof ActivityLocationScalarFieldEnum]

export const AttendingScalarFieldEnum = {
	id: 'id',
	userId: 'userId',
	activityId: 'activityId',
	status: 'status',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	isActive: 'isActive',
} as const

export type AttendingScalarFieldEnum = (typeof AttendingScalarFieldEnum)[keyof typeof AttendingScalarFieldEnum]

export const LedgerScalarFieldEnum = {
	id: 'id',
	name: 'name',
	description: 'description',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	isActive: 'isActive',
} as const

export type LedgerScalarFieldEnum = (typeof LedgerScalarFieldEnum)[keyof typeof LedgerScalarFieldEnum]

export const ProductCategoryScalarFieldEnum = {
	id: 'id',
	name: 'name',
	description: 'description',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	isActive: 'isActive',
} as const

export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]

export const ProductScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	name: 'name',
	description: 'description',
	price: 'price',
	productType: 'productType',
	data: 'data',
	categoryId: 'categoryId',
	isActive: 'isActive',
} as const

export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]

export const FinancialPersonScalarFieldEnum = {
	id: 'id',
	type: 'type',
	name: 'name',
	balance: 'balance',
	isActive: 'isActive',
} as const

export type FinancialPersonScalarFieldEnum = (typeof FinancialPersonScalarFieldEnum)[keyof typeof FinancialPersonScalarFieldEnum]

export const FinancialPersonDataUserScalarFieldEnum = {
	personId: 'personId',
	userId: 'userId',
	iban: 'iban',
} as const

export type FinancialPersonDataUserScalarFieldEnum =
	(typeof FinancialPersonDataUserScalarFieldEnum)[keyof typeof FinancialPersonDataUserScalarFieldEnum]

export const FinancialGroupScalarFieldEnum = {
	personId: 'personId',
} as const

export type FinancialGroupScalarFieldEnum = (typeof FinancialGroupScalarFieldEnum)[keyof typeof FinancialGroupScalarFieldEnum]

export const FinancialGroupPersonElementScalarFieldEnum = {
	groupId: 'groupId',
	personId: 'personId',
} as const

export type FinancialGroupPersonElementScalarFieldEnum =
	(typeof FinancialGroupPersonElementScalarFieldEnum)[keyof typeof FinancialGroupPersonElementScalarFieldEnum]

export const FinancialPersonDataActivityScalarFieldEnum = {
	personId: 'personId',
	activityId: 'activityId',
} as const

export type FinancialPersonDataActivityScalarFieldEnum =
	(typeof FinancialPersonDataActivityScalarFieldEnum)[keyof typeof FinancialPersonDataActivityScalarFieldEnum]

export const FinancialPersonDataCommitteeScalarFieldEnum = {
	personId: 'personId',
	committeeId: 'committeeId',
} as const

export type FinancialPersonDataCommitteeScalarFieldEnum =
	(typeof FinancialPersonDataCommitteeScalarFieldEnum)[keyof typeof FinancialPersonDataCommitteeScalarFieldEnum]

export const FinancialPersonDataOtherScalarFieldEnum = {
	personId: 'personId',
	description: 'description',
	email: 'email',
	address: 'address',
	postalCode: 'postalCode',
	city: 'city',
	iban: 'iban',
} as const

export type FinancialPersonDataOtherScalarFieldEnum =
	(typeof FinancialPersonDataOtherScalarFieldEnum)[keyof typeof FinancialPersonDataOtherScalarFieldEnum]

export const TransactionScalarFieldEnum = {
	id: 'id',
	type: 'type',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]

export const TransactionMatchRowScalarFieldEnum = {
	id: 'id',
	description: 'description',
	amount: 'amount',
	transactionId: 'transactionId',
	saldoTransactionId: 'saldoTransactionId',
	journalId: 'journalId',
} as const

export type TransactionMatchRowScalarFieldEnum =
	(typeof TransactionMatchRowScalarFieldEnum)[keyof typeof TransactionMatchRowScalarFieldEnum]

export const SaldoTransactionScalarFieldEnum = {
	id: 'id',
	description: 'description',
	price: 'price',
	fromId: 'fromId',
	toId: 'toId',
	transactionId: 'transactionId',
} as const

export type SaldoTransactionScalarFieldEnum = (typeof SaldoTransactionScalarFieldEnum)[keyof typeof SaldoTransactionScalarFieldEnum]

export const BankTransactionScalarFieldEnum = {
	id: 'id',
	ref: 'ref',
	type: 'type',
	product: 'product',
	startedDate: 'startedDate',
	completedDate: 'completedDate',
	description: 'description',
	amount: 'amount',
	fee: 'fee',
	relationId: 'relationId',
	transactionId: 'transactionId',
} as const

export type BankTransactionScalarFieldEnum = (typeof BankTransactionScalarFieldEnum)[keyof typeof BankTransactionScalarFieldEnum]

export const StreeplijstScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	startDate: 'startDate',
	endDate: 'endDate',
	userId: 'userId',
	notes: 'notes',
} as const

export type StreeplijstScalarFieldEnum = (typeof StreeplijstScalarFieldEnum)[keyof typeof StreeplijstScalarFieldEnum]

export const JournalScalarFieldEnum = {
	id: 'id',
	ref: 'ref',
	date: 'date',
	termsOfPayment: 'termsOfPayment',
	tav: 'tav',
	description: 'description',
	type: 'type',
	relationId: 'relationId',
	treasurerId: 'treasurerId',
	streeplijstId: 'streeplijstId',
} as const

export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]

export const DeclarationDataScalarFieldEnum = {
	id: 'id',
	methodOfPayment: 'methodOfPayment',
	receiveMethod: 'receiveMethod',
	status: 'status',
	iban: 'iban',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	askedAmount: 'askedAmount',
	reason: 'reason',
	financialPersonId: 'financialPersonId',
	journalId: 'journalId',
} as const

export type DeclarationDataScalarFieldEnum = (typeof DeclarationDataScalarFieldEnum)[keyof typeof DeclarationDataScalarFieldEnum]

export const JournalRowScalarFieldEnum = {
	id: 'id',
	amount: 'amount',
	price: 'price',
	description: 'description',
	productId: 'productId',
	ledgerId: 'ledgerId',
	journalId: 'journalId',
} as const

export type JournalRowScalarFieldEnum = (typeof JournalRowScalarFieldEnum)[keyof typeof JournalRowScalarFieldEnum]

export const LinkScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	link: 'link',
	shortLink: 'shortLink',
	userId: 'userId',
} as const

export type LinkScalarFieldEnum = (typeof LinkScalarFieldEnum)[keyof typeof LinkScalarFieldEnum]

export const LinkClickScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	linkId: 'linkId',
	userId: 'userId',
} as const

export type LinkClickScalarFieldEnum = (typeof LinkClickScalarFieldEnum)[keyof typeof LinkClickScalarFieldEnum]

export const EmailAliasScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	alias: 'alias',
} as const

export type EmailAliasScalarFieldEnum = (typeof EmailAliasScalarFieldEnum)[keyof typeof EmailAliasScalarFieldEnum]

export const EmailAliasCommitteeScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	emailAliasId: 'emailAliasId',
	committeeId: 'committeeId',
} as const

export type EmailAliasCommitteeScalarFieldEnum =
	(typeof EmailAliasCommitteeScalarFieldEnum)[keyof typeof EmailAliasCommitteeScalarFieldEnum]

export const EmailAliasUserScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	emailAliasId: 'emailAliasId',
	userId: 'userId',
} as const

export type EmailAliasUserScalarFieldEnum = (typeof EmailAliasUserScalarFieldEnum)[keyof typeof EmailAliasUserScalarFieldEnum]

export const EmailContactScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	address: 'address',
	emailAliasId: 'emailAliasId',
} as const

export type EmailContactScalarFieldEnum = (typeof EmailContactScalarFieldEnum)[keyof typeof EmailContactScalarFieldEnum]

export const ClickSessionScalarFieldEnum = {
	id: 'id',
	userId: 'userId',
	amount: 'amount',
	startTime: 'startTime',
	endTime: 'endTime',
} as const

export type ClickSessionScalarFieldEnum = (typeof ClickSessionScalarFieldEnum)[keyof typeof ClickSessionScalarFieldEnum]

export const TrackScalarFieldEnum = {
	id: 'id',
	inPlaylist: 'inPlaylist',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
} as const

export type TrackScalarFieldEnum = (typeof TrackScalarFieldEnum)[keyof typeof TrackScalarFieldEnum]

export const TrackReactionScalarFieldEnum = {
	userId: 'userId',
	trackId: 'trackId',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	liked: 'liked',
} as const

export type TrackReactionScalarFieldEnum = (typeof TrackReactionScalarFieldEnum)[keyof typeof TrackReactionScalarFieldEnum]

export const PhotoScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	date: 'date',
	visible: 'visible',
	fileId: 'fileId',
	description: 'description',
	uploaderId: 'uploaderId',
	creatorId: 'creatorId',
	activityPhotoId: 'activityPhotoId',
} as const

export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]

export const PhotoTagScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	name: 'name',
} as const

export type PhotoTagScalarFieldEnum = (typeof PhotoTagScalarFieldEnum)[keyof typeof PhotoTagScalarFieldEnum]

export const PhotosWithTagsScalarFieldEnum = {
	photoId: 'photoId',
	photoTagId: 'photoTagId',
	assignedById: 'assignedById',
} as const

export type PhotosWithTagsScalarFieldEnum = (typeof PhotosWithTagsScalarFieldEnum)[keyof typeof PhotosWithTagsScalarFieldEnum]

export const PhotoPersonTagScalarFieldEnum = {
	taggerId: 'taggerId',
	photoId: 'photoId',
	userId: 'userId',
} as const

export type PhotoPersonTagScalarFieldEnum = (typeof PhotoPersonTagScalarFieldEnum)[keyof typeof PhotoPersonTagScalarFieldEnum]

export const PhotoRatingScalarFieldEnum = {
	rating: 'rating',
	photoId: 'photoId',
	userId: 'userId',
} as const

export type PhotoRatingScalarFieldEnum = (typeof PhotoRatingScalarFieldEnum)[keyof typeof PhotoRatingScalarFieldEnum]

export const CommentScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	comment: 'comment',
	commenterId: 'commenterId',
	photoId: 'photoId',
	activityId: 'activityId',
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]

export const LeaderboardScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	pinned: 'pinned',
	name: 'name',
	description: 'description',
	type: 'type',
	sortBy: 'sortBy',
	opensAt: 'opensAt',
	closesAt: 'closesAt',
} as const

export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]

export const LeaderboardEntryScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	leaderboardId: 'leaderboardId',
	userId: 'userId',
	challengerId: 'challengerId',
	value: 'value',
} as const

export type LeaderboardEntryScalarFieldEnum = (typeof LeaderboardEntryScalarFieldEnum)[keyof typeof LeaderboardEntryScalarFieldEnum]

export const LeaderboardChallengerScalarFieldEnum = {
	id: 'id',
	firstName: 'firstName',
	lastName: 'lastName',
} as const

export type LeaderboardChallengerScalarFieldEnum =
	(typeof LeaderboardChallengerScalarFieldEnum)[keyof typeof LeaderboardChallengerScalarFieldEnum]

export const LeaderboardChallengerUserScalarFieldEnum = {
	challengerId: 'challengerId',
	userId: 'userId',
} as const

export type LeaderboardChallengerUserScalarFieldEnum =
	(typeof LeaderboardChallengerUserScalarFieldEnum)[keyof typeof LeaderboardChallengerUserScalarFieldEnum]

export const FileScalarFieldEnum = {
	id: 'id',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	filename: 'filename',
	deletedAt: 'deletedAt',
	deleted: 'deleted',
	uploaderId: 'uploaderId',
	journalId: 'journalId',
} as const

export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]

export const JobScalarFieldEnum = {
	name: 'name',
	createdAt: 'createdAt',
	updatedAt: 'updatedAt',
	data: 'data',
	type: 'type',
	finished: 'finished',
	completedAt: 'completedAt',
	result: 'result',
} as const

export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]

export const NotificationScalarFieldEnum = {
	id: 'id',
	title: 'title',
	body: 'body',
	type: 'type',
	sent: 'sent',
	userId: 'userId',
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]

export const SortOrder = {
	asc: 'asc',
	desc: 'desc',
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]

export const JsonNullValueInput = {
	JsonNull: JsonNull,
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]

export const SettingsOrderByRelevanceFieldEnum = {
	name: 'name',
	description: 'description',
	value: 'value',
} as const

export type SettingsOrderByRelevanceFieldEnum = (typeof SettingsOrderByRelevanceFieldEnum)[keyof typeof SettingsOrderByRelevanceFieldEnum]

export const BasePreferenceOrderByRelevanceFieldEnum = {
	key: 'key',
	description: 'description',
} as const

export type BasePreferenceOrderByRelevanceFieldEnum =
	(typeof BasePreferenceOrderByRelevanceFieldEnum)[keyof typeof BasePreferenceOrderByRelevanceFieldEnum]

export const NullsOrder = {
	first: 'first',
	last: 'last',
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]

export const UserOrderByRelevanceFieldEnum = {
	firstName: 'firstName',
	lastName: 'lastName',
	ldapId: 'ldapId',
	email: 'email',
	personalEmail: 'personalEmail',
	nickname: 'nickname',
	profilePicture: 'profilePicture',
	phone: 'phone',
	preferredTheme: 'preferredTheme',
} as const

export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]

export const AccountOrderByRelevanceFieldEnum = {
	id: 'id',
	type: 'type',
	provider: 'provider',
	providerAccountId: 'providerAccountId',
	refresh_token: 'refresh_token',
	access_token: 'access_token',
	token_type: 'token_type',
	scope: 'scope',
	id_token: 'id_token',
	session_state: 'session_state',
} as const

export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]

export const UnlinkedAccountOrderByRelevanceFieldEnum = {
	id: 'id',
	providerAccountId: 'providerAccountId',
} as const

export type UnlinkedAccountOrderByRelevanceFieldEnum =
	(typeof UnlinkedAccountOrderByRelevanceFieldEnum)[keyof typeof UnlinkedAccountOrderByRelevanceFieldEnum]

export const SessionOrderByRelevanceFieldEnum = {
	id: 'id',
	sessionToken: 'sessionToken',
} as const

export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]

export const AccessTokenOrderByRelevanceFieldEnum = {
	token: 'token',
	name: 'name',
	type: 'type',
} as const

export type AccessTokenOrderByRelevanceFieldEnum =
	(typeof AccessTokenOrderByRelevanceFieldEnum)[keyof typeof AccessTokenOrderByRelevanceFieldEnum]

export const CommitteeOrderByRelevanceFieldEnum = {
	name: 'name',
	ldapId: 'ldapId',
} as const

export type CommitteeOrderByRelevanceFieldEnum =
	(typeof CommitteeOrderByRelevanceFieldEnum)[keyof typeof CommitteeOrderByRelevanceFieldEnum]

export const CommitteeMemberOrderByRelevanceFieldEnum = {
	function: 'function',
} as const

export type CommitteeMemberOrderByRelevanceFieldEnum =
	(typeof CommitteeMemberOrderByRelevanceFieldEnum)[keyof typeof CommitteeMemberOrderByRelevanceFieldEnum]

export const StrafbakOrderByRelevanceFieldEnum = {
	reason: 'reason',
	location: 'location',
} as const

export type StrafbakOrderByRelevanceFieldEnum = (typeof StrafbakOrderByRelevanceFieldEnum)[keyof typeof StrafbakOrderByRelevanceFieldEnum]

export const MaluspuntOrderByRelevanceFieldEnum = {
	reason: 'reason',
} as const

export type MaluspuntOrderByRelevanceFieldEnum =
	(typeof MaluspuntOrderByRelevanceFieldEnum)[keyof typeof MaluspuntOrderByRelevanceFieldEnum]

export const ActivityOrderByRelevanceFieldEnum = {
	name: 'name',
	description: 'description',
	photo: 'photo',
	url: 'url',
} as const

export type ActivityOrderByRelevanceFieldEnum = (typeof ActivityOrderByRelevanceFieldEnum)[keyof typeof ActivityOrderByRelevanceFieldEnum]

export const ActivityLocationOrderByRelevanceFieldEnum = {
	name: 'name',
	adress: 'adress',
	country: 'country',
	postalCode: 'postalCode',
	city: 'city',
	description: 'description',
} as const

export type ActivityLocationOrderByRelevanceFieldEnum =
	(typeof ActivityLocationOrderByRelevanceFieldEnum)[keyof typeof ActivityLocationOrderByRelevanceFieldEnum]

export const LedgerOrderByRelevanceFieldEnum = {
	name: 'name',
	description: 'description',
} as const

export type LedgerOrderByRelevanceFieldEnum = (typeof LedgerOrderByRelevanceFieldEnum)[keyof typeof LedgerOrderByRelevanceFieldEnum]

export const ProductCategoryOrderByRelevanceFieldEnum = {
	name: 'name',
	description: 'description',
} as const

export type ProductCategoryOrderByRelevanceFieldEnum =
	(typeof ProductCategoryOrderByRelevanceFieldEnum)[keyof typeof ProductCategoryOrderByRelevanceFieldEnum]

export const JsonNullValueFilter = {
	DbNull: DbNull,
	JsonNull: JsonNull,
	AnyNull: AnyNull,
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]

export const QueryMode = {
	default: 'default',
	insensitive: 'insensitive',
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]

export const ProductOrderByRelevanceFieldEnum = {
	name: 'name',
	description: 'description',
} as const

export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]

export const FinancialPersonOrderByRelevanceFieldEnum = {
	name: 'name',
} as const

export type FinancialPersonOrderByRelevanceFieldEnum =
	(typeof FinancialPersonOrderByRelevanceFieldEnum)[keyof typeof FinancialPersonOrderByRelevanceFieldEnum]

export const FinancialPersonDataUserOrderByRelevanceFieldEnum = {
	iban: 'iban',
} as const

export type FinancialPersonDataUserOrderByRelevanceFieldEnum =
	(typeof FinancialPersonDataUserOrderByRelevanceFieldEnum)[keyof typeof FinancialPersonDataUserOrderByRelevanceFieldEnum]

export const FinancialPersonDataOtherOrderByRelevanceFieldEnum = {
	description: 'description',
	email: 'email',
	address: 'address',
	postalCode: 'postalCode',
	city: 'city',
	iban: 'iban',
} as const

export type FinancialPersonDataOtherOrderByRelevanceFieldEnum =
	(typeof FinancialPersonDataOtherOrderByRelevanceFieldEnum)[keyof typeof FinancialPersonDataOtherOrderByRelevanceFieldEnum]

export const TransactionMatchRowOrderByRelevanceFieldEnum = {
	description: 'description',
} as const

export type TransactionMatchRowOrderByRelevanceFieldEnum =
	(typeof TransactionMatchRowOrderByRelevanceFieldEnum)[keyof typeof TransactionMatchRowOrderByRelevanceFieldEnum]

export const SaldoTransactionOrderByRelevanceFieldEnum = {
	description: 'description',
} as const

export type SaldoTransactionOrderByRelevanceFieldEnum =
	(typeof SaldoTransactionOrderByRelevanceFieldEnum)[keyof typeof SaldoTransactionOrderByRelevanceFieldEnum]

export const BankTransactionOrderByRelevanceFieldEnum = {
	ref: 'ref',
	description: 'description',
} as const

export type BankTransactionOrderByRelevanceFieldEnum =
	(typeof BankTransactionOrderByRelevanceFieldEnum)[keyof typeof BankTransactionOrderByRelevanceFieldEnum]

export const StreeplijstOrderByRelevanceFieldEnum = {
	notes: 'notes',
} as const

export type StreeplijstOrderByRelevanceFieldEnum =
	(typeof StreeplijstOrderByRelevanceFieldEnum)[keyof typeof StreeplijstOrderByRelevanceFieldEnum]

export const JournalOrderByRelevanceFieldEnum = {
	ref: 'ref',
	tav: 'tav',
	description: 'description',
} as const

export type JournalOrderByRelevanceFieldEnum = (typeof JournalOrderByRelevanceFieldEnum)[keyof typeof JournalOrderByRelevanceFieldEnum]

export const DeclarationDataOrderByRelevanceFieldEnum = {
	methodOfPayment: 'methodOfPayment',
	iban: 'iban',
	reason: 'reason',
} as const

export type DeclarationDataOrderByRelevanceFieldEnum =
	(typeof DeclarationDataOrderByRelevanceFieldEnum)[keyof typeof DeclarationDataOrderByRelevanceFieldEnum]

export const JournalRowOrderByRelevanceFieldEnum = {
	description: 'description',
} as const

export type JournalRowOrderByRelevanceFieldEnum =
	(typeof JournalRowOrderByRelevanceFieldEnum)[keyof typeof JournalRowOrderByRelevanceFieldEnum]

export const LinkOrderByRelevanceFieldEnum = {
	link: 'link',
	shortLink: 'shortLink',
} as const

export type LinkOrderByRelevanceFieldEnum = (typeof LinkOrderByRelevanceFieldEnum)[keyof typeof LinkOrderByRelevanceFieldEnum]

export const EmailAliasOrderByRelevanceFieldEnum = {
	alias: 'alias',
} as const

export type EmailAliasOrderByRelevanceFieldEnum =
	(typeof EmailAliasOrderByRelevanceFieldEnum)[keyof typeof EmailAliasOrderByRelevanceFieldEnum]

export const EmailContactOrderByRelevanceFieldEnum = {
	address: 'address',
} as const

export type EmailContactOrderByRelevanceFieldEnum =
	(typeof EmailContactOrderByRelevanceFieldEnum)[keyof typeof EmailContactOrderByRelevanceFieldEnum]

export const TrackOrderByRelevanceFieldEnum = {
	id: 'id',
} as const

export type TrackOrderByRelevanceFieldEnum = (typeof TrackOrderByRelevanceFieldEnum)[keyof typeof TrackOrderByRelevanceFieldEnum]

export const TrackReactionOrderByRelevanceFieldEnum = {
	trackId: 'trackId',
} as const

export type TrackReactionOrderByRelevanceFieldEnum =
	(typeof TrackReactionOrderByRelevanceFieldEnum)[keyof typeof TrackReactionOrderByRelevanceFieldEnum]

export const PhotoOrderByRelevanceFieldEnum = {
	fileId: 'fileId',
	description: 'description',
} as const

export type PhotoOrderByRelevanceFieldEnum = (typeof PhotoOrderByRelevanceFieldEnum)[keyof typeof PhotoOrderByRelevanceFieldEnum]

export const PhotoTagOrderByRelevanceFieldEnum = {
	name: 'name',
} as const

export type PhotoTagOrderByRelevanceFieldEnum = (typeof PhotoTagOrderByRelevanceFieldEnum)[keyof typeof PhotoTagOrderByRelevanceFieldEnum]

export const CommentOrderByRelevanceFieldEnum = {
	comment: 'comment',
} as const

export type CommentOrderByRelevanceFieldEnum = (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum]

export const LeaderboardOrderByRelevanceFieldEnum = {
	id: 'id',
	name: 'name',
	description: 'description',
} as const

export type LeaderboardOrderByRelevanceFieldEnum =
	(typeof LeaderboardOrderByRelevanceFieldEnum)[keyof typeof LeaderboardOrderByRelevanceFieldEnum]

export const LeaderboardEntryOrderByRelevanceFieldEnum = {
	leaderboardId: 'leaderboardId',
	challengerId: 'challengerId',
} as const

export type LeaderboardEntryOrderByRelevanceFieldEnum =
	(typeof LeaderboardEntryOrderByRelevanceFieldEnum)[keyof typeof LeaderboardEntryOrderByRelevanceFieldEnum]

export const LeaderboardChallengerOrderByRelevanceFieldEnum = {
	id: 'id',
	firstName: 'firstName',
	lastName: 'lastName',
} as const

export type LeaderboardChallengerOrderByRelevanceFieldEnum =
	(typeof LeaderboardChallengerOrderByRelevanceFieldEnum)[keyof typeof LeaderboardChallengerOrderByRelevanceFieldEnum]

export const LeaderboardChallengerUserOrderByRelevanceFieldEnum = {
	challengerId: 'challengerId',
} as const

export type LeaderboardChallengerUserOrderByRelevanceFieldEnum =
	(typeof LeaderboardChallengerUserOrderByRelevanceFieldEnum)[keyof typeof LeaderboardChallengerUserOrderByRelevanceFieldEnum]

export const FileOrderByRelevanceFieldEnum = {
	id: 'id',
	filename: 'filename',
} as const

export type FileOrderByRelevanceFieldEnum = (typeof FileOrderByRelevanceFieldEnum)[keyof typeof FileOrderByRelevanceFieldEnum]

export const JobOrderByRelevanceFieldEnum = {
	name: 'name',
	data: 'data',
	type: 'type',
	result: 'result',
} as const

export type JobOrderByRelevanceFieldEnum = (typeof JobOrderByRelevanceFieldEnum)[keyof typeof JobOrderByRelevanceFieldEnum]

export const NotificationOrderByRelevanceFieldEnum = {
	title: 'title',
	body: 'body',
} as const

export type NotificationOrderByRelevanceFieldEnum =
	(typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]

/**
 * Field references
 */

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>

/**
 * Reference to a field of type 'AttendingStatus'
 */
export type EnumAttendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendingStatus'>

/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>

/**
 * Reference to a field of type 'ProductType'
 */
export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>

/**
 * Reference to a field of type 'FinancialPersonType'
 */
export type EnumFinancialPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialPersonType'>

/**
 * Reference to a field of type 'TransactionType'
 */
export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>

/**
 * Reference to a field of type 'BankTransactionType'
 */
export type EnumBankTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankTransactionType'>

/**
 * Reference to a field of type 'BankTransactionProduct'
 */
export type EnumBankTransactionProductFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankTransactionProduct'>

/**
 * Reference to a field of type 'JournalType'
 */
export type EnumJournalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalType'>

/**
 * Reference to a field of type 'ReceiveMethod'
 */
export type EnumReceiveMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReceiveMethod'>

/**
 * Reference to a field of type 'DeclarationStatus'
 */
export type EnumDeclarationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeclarationStatus'>

/**
 * Reference to a field of type 'LeaderboardTypes'
 */
export type EnumLeaderboardTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaderboardTypes'>

/**
 * Reference to a field of type 'LeaderboardSort'
 */
export type EnumLeaderboardSortFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaderboardSort'>

/**
 * Reference to a field of type 'NotificationType'
 */
export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
	count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
	'define',
	TypeMapCb,
	runtime.Types.Extensions.DefaultArgs
>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = (
	| {
			/**
			 * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
			 */
			adapter: runtime.SqlDriverAdapterFactory
			accelerateUrl?: never
	  }
	| {
			/**
			 * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
			 */
			accelerateUrl: string
			adapter?: never
	  }
) & {
	/**
	 * @default "colorless"
	 */
	errorFormat?: ErrorFormat
	/**
	 * @example
	 * ```
	 * // Shorthand for `emit: 'stdout'`
	 * log: ['query', 'info', 'warn', 'error']
	 *
	 * // Emit as events only
	 * log: [
	 *   { emit: 'event', level: 'query' },
	 *   { emit: 'event', level: 'info' },
	 *   { emit: 'event', level: 'warn' }
	 *   { emit: 'event', level: 'error' }
	 * ]
	 *
	 * / Emit as events and log to stdout
	 * og: [
	 *  { emit: 'stdout', level: 'query' },
	 *  { emit: 'stdout', level: 'info' },
	 *  { emit: 'stdout', level: 'warn' }
	 *  { emit: 'stdout', level: 'error' }
	 *
	 * ```
	 * Read more in our [docs](https://pris.ly/d/logging).
	 */
	log?: (LogLevel | LogDefinition)[]
	/**
	 * The default values for transactionOptions
	 * maxWait ?= 2000
	 * timeout ?= 5000
	 */
	transactionOptions?: {
		maxWait?: number
		timeout?: number
		isolationLevel?: TransactionIsolationLevel
	}
	/**
	 * Global configuration for omitting model fields by default.
	 *
	 * @example
	 * ```
	 * const prisma = new PrismaClient({
	 *   omit: {
	 *     user: {
	 *       password: true
	 *     }
	 *   }
	 * })
	 * ```
	 */
	omit?: GlobalOmitConfig
	/**
	 * SQL commenter plugins that add metadata to SQL queries as comments.
	 * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
	 *
	 * @example
	 * ```
	 * const prisma = new PrismaClient({
	 *   adapter,
	 *   comments: [
	 *     traceContext(),
	 *     queryInsights(),
	 *   ],
	 * })
	 * ```
	 */
	comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
	settings?: Prisma.SettingsOmit
	basePreference?: Prisma.BasePreferenceOmit
	preference?: Prisma.PreferenceOmit
	user?: Prisma.UserOmit
	account?: Prisma.AccountOmit
	unlinkedAccount?: Prisma.UnlinkedAccountOmit
	session?: Prisma.SessionOmit
	accessToken?: Prisma.AccessTokenOmit
	committee?: Prisma.CommitteeOmit
	committeeMember?: Prisma.CommitteeMemberOmit
	strafbak?: Prisma.StrafbakOmit
	maluspunt?: Prisma.MaluspuntOmit
	activity?: Prisma.ActivityOmit
	activityLocation?: Prisma.ActivityLocationOmit
	attending?: Prisma.AttendingOmit
	ledger?: Prisma.LedgerOmit
	productCategory?: Prisma.ProductCategoryOmit
	product?: Prisma.ProductOmit
	financialPerson?: Prisma.FinancialPersonOmit
	financialPersonDataUser?: Prisma.FinancialPersonDataUserOmit
	financialGroup?: Prisma.FinancialGroupOmit
	financialGroupPersonElement?: Prisma.FinancialGroupPersonElementOmit
	financialPersonDataActivity?: Prisma.FinancialPersonDataActivityOmit
	financialPersonDataCommittee?: Prisma.FinancialPersonDataCommitteeOmit
	financialPersonDataOther?: Prisma.FinancialPersonDataOtherOmit
	transaction?: Prisma.TransactionOmit
	transactionMatchRow?: Prisma.TransactionMatchRowOmit
	saldoTransaction?: Prisma.SaldoTransactionOmit
	bankTransaction?: Prisma.BankTransactionOmit
	streeplijst?: Prisma.StreeplijstOmit
	journal?: Prisma.JournalOmit
	declarationData?: Prisma.DeclarationDataOmit
	journalRow?: Prisma.JournalRowOmit
	link?: Prisma.LinkOmit
	linkClick?: Prisma.LinkClickOmit
	emailAlias?: Prisma.EmailAliasOmit
	emailAliasCommittee?: Prisma.EmailAliasCommitteeOmit
	emailAliasUser?: Prisma.EmailAliasUserOmit
	emailContact?: Prisma.EmailContactOmit
	clickSession?: Prisma.ClickSessionOmit
	track?: Prisma.TrackOmit
	trackReaction?: Prisma.TrackReactionOmit
	photo?: Prisma.PhotoOmit
	photoTag?: Prisma.PhotoTagOmit
	photosWithTags?: Prisma.PhotosWithTagsOmit
	photoPersonTag?: Prisma.PhotoPersonTagOmit
	photoRating?: Prisma.PhotoRatingOmit
	comment?: Prisma.CommentOmit
	leaderboard?: Prisma.LeaderboardOmit
	leaderboardEntry?: Prisma.LeaderboardEntryOmit
	leaderboardChallenger?: Prisma.LeaderboardChallengerOmit
	leaderboardChallengerUser?: Prisma.LeaderboardChallengerUserOmit
	file?: Prisma.FileOmit
	job?: Prisma.JobOmit
	notification?: Prisma.NotificationOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
	level: LogLevel
	emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never

export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never

export type QueryEvent = {
	timestamp: Date
	query: string
	params: string
	duration: number
	target: string
}

export type LogEvent = {
	timestamp: Date
	message: string
	target: string
}
/* End Types for Logging */

export type PrismaAction =
	| 'findUnique'
	| 'findUniqueOrThrow'
	| 'findMany'
	| 'findFirst'
	| 'findFirstOrThrow'
	| 'create'
	| 'createMany'
	| 'createManyAndReturn'
	| 'update'
	| 'updateMany'
	| 'updateManyAndReturn'
	| 'upsert'
	| 'delete'
	| 'deleteMany'
	| 'executeRaw'
	| 'queryRaw'
	| 'aggregate'
	| 'count'
	| 'runCommandRaw'
	| 'findRaw'
	| 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

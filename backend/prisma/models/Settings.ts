/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Settings` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client'
import type * as $Enums from '../enums.js'
import type * as Prisma from '../internal/prismaNamespace.js'

/**
 * Model Settings
 *
 */
export type SettingsModel = runtime.Types.Result.DefaultSelection<Prisma.$SettingsPayload>

export type AggregateSettings = {
	_count: SettingsCountAggregateOutputType | null
	_avg: SettingsAvgAggregateOutputType | null
	_sum: SettingsSumAggregateOutputType | null
	_min: SettingsMinAggregateOutputType | null
	_max: SettingsMaxAggregateOutputType | null
}

export type SettingsAvgAggregateOutputType = {
	id: number | null
}

export type SettingsSumAggregateOutputType = {
	id: number | null
}

export type SettingsMinAggregateOutputType = {
	id: number | null
	name: string | null
	description: string | null
	value: string | null
	createdAt: Date | null
	updatedAt: Date | null
}

export type SettingsMaxAggregateOutputType = {
	id: number | null
	name: string | null
	description: string | null
	value: string | null
	createdAt: Date | null
	updatedAt: Date | null
}

export type SettingsCountAggregateOutputType = {
	id: number
	name: number
	description: number
	value: number
	createdAt: number
	updatedAt: number
	_all: number
}

export type SettingsAvgAggregateInputType = {
	id?: true
}

export type SettingsSumAggregateInputType = {
	id?: true
}

export type SettingsMinAggregateInputType = {
	id?: true
	name?: true
	description?: true
	value?: true
	createdAt?: true
	updatedAt?: true
}

export type SettingsMaxAggregateInputType = {
	id?: true
	name?: true
	description?: true
	value?: true
	createdAt?: true
	updatedAt?: true
}

export type SettingsCountAggregateInputType = {
	id?: true
	name?: true
	description?: true
	value?: true
	createdAt?: true
	updatedAt?: true
	_all?: true
}

export type SettingsAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Filter which Settings to aggregate.
	 */
	where?: Prisma.SettingsWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Settings to fetch.
	 */
	orderBy?: Prisma.SettingsOrderByWithRelationInput | Prisma.SettingsOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.SettingsWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Settings from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Settings.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Settings
	 **/
	_count?: true | SettingsCountAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: SettingsAvgAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: SettingsSumAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: SettingsMinAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: SettingsMaxAggregateInputType
}

export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
	[P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateSettings[P]>
		: Prisma.GetScalarType<T[P], AggregateSettings[P]>
}

export type SettingsGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	where?: Prisma.SettingsWhereInput
	orderBy?: Prisma.SettingsOrderByWithAggregationInput | Prisma.SettingsOrderByWithAggregationInput[]
	by: Prisma.SettingsScalarFieldEnum[] | Prisma.SettingsScalarFieldEnum
	having?: Prisma.SettingsScalarWhereWithAggregatesInput
	take?: number
	skip?: number
	_count?: SettingsCountAggregateInputType | true
	_avg?: SettingsAvgAggregateInputType
	_sum?: SettingsSumAggregateInputType
	_min?: SettingsMinAggregateInputType
	_max?: SettingsMaxAggregateInputType
}

export type SettingsGroupByOutputType = {
	id: number
	name: string
	description: string
	value: string
	createdAt: Date
	updatedAt: Date
	_count: SettingsCountAggregateOutputType | null
	_avg: SettingsAvgAggregateOutputType | null
	_sum: SettingsSumAggregateOutputType | null
	_min: SettingsMinAggregateOutputType | null
	_max: SettingsMaxAggregateOutputType | null
}

type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<SettingsGroupByOutputType, T['by']> & {
			[P in keyof T & keyof SettingsGroupByOutputType]: P extends '_count'
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], SettingsGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], SettingsGroupByOutputType[P]>
		}
	>
>

export type SettingsWhereInput = {
	AND?: Prisma.SettingsWhereInput | Prisma.SettingsWhereInput[]
	OR?: Prisma.SettingsWhereInput[]
	NOT?: Prisma.SettingsWhereInput | Prisma.SettingsWhereInput[]
	id?: Prisma.IntFilter<'Settings'> | number
	name?: Prisma.StringFilter<'Settings'> | string
	description?: Prisma.StringFilter<'Settings'> | string
	value?: Prisma.StringFilter<'Settings'> | string
	createdAt?: Prisma.DateTimeFilter<'Settings'> | Date | string
	updatedAt?: Prisma.DateTimeFilter<'Settings'> | Date | string
}

export type SettingsOrderByWithRelationInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	description?: Prisma.SortOrder
	value?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	_relevance?: Prisma.SettingsOrderByRelevanceInput
}

export type SettingsWhereUniqueInput = Prisma.AtLeast<
	{
		id?: number
		name?: string
		AND?: Prisma.SettingsWhereInput | Prisma.SettingsWhereInput[]
		OR?: Prisma.SettingsWhereInput[]
		NOT?: Prisma.SettingsWhereInput | Prisma.SettingsWhereInput[]
		description?: Prisma.StringFilter<'Settings'> | string
		value?: Prisma.StringFilter<'Settings'> | string
		createdAt?: Prisma.DateTimeFilter<'Settings'> | Date | string
		updatedAt?: Prisma.DateTimeFilter<'Settings'> | Date | string
	},
	'id' | 'name'
>

export type SettingsOrderByWithAggregationInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	description?: Prisma.SortOrder
	value?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	_count?: Prisma.SettingsCountOrderByAggregateInput
	_avg?: Prisma.SettingsAvgOrderByAggregateInput
	_max?: Prisma.SettingsMaxOrderByAggregateInput
	_min?: Prisma.SettingsMinOrderByAggregateInput
	_sum?: Prisma.SettingsSumOrderByAggregateInput
}

export type SettingsScalarWhereWithAggregatesInput = {
	AND?: Prisma.SettingsScalarWhereWithAggregatesInput | Prisma.SettingsScalarWhereWithAggregatesInput[]
	OR?: Prisma.SettingsScalarWhereWithAggregatesInput[]
	NOT?: Prisma.SettingsScalarWhereWithAggregatesInput | Prisma.SettingsScalarWhereWithAggregatesInput[]
	id?: Prisma.IntWithAggregatesFilter<'Settings'> | number
	name?: Prisma.StringWithAggregatesFilter<'Settings'> | string
	description?: Prisma.StringWithAggregatesFilter<'Settings'> | string
	value?: Prisma.StringWithAggregatesFilter<'Settings'> | string
	createdAt?: Prisma.DateTimeWithAggregatesFilter<'Settings'> | Date | string
	updatedAt?: Prisma.DateTimeWithAggregatesFilter<'Settings'> | Date | string
}

export type SettingsCreateInput = {
	name: string
	description: string
	value: string
	createdAt?: Date | string
	updatedAt?: Date | string
}

export type SettingsUncheckedCreateInput = {
	id?: number
	name: string
	description: string
	value: string
	createdAt?: Date | string
	updatedAt?: Date | string
}

export type SettingsUpdateInput = {
	name?: Prisma.StringFieldUpdateOperationsInput | string
	description?: Prisma.StringFieldUpdateOperationsInput | string
	value?: Prisma.StringFieldUpdateOperationsInput | string
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SettingsUncheckedUpdateInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number
	name?: Prisma.StringFieldUpdateOperationsInput | string
	description?: Prisma.StringFieldUpdateOperationsInput | string
	value?: Prisma.StringFieldUpdateOperationsInput | string
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SettingsCreateManyInput = {
	id?: number
	name: string
	description: string
	value: string
	createdAt?: Date | string
	updatedAt?: Date | string
}

export type SettingsUpdateManyMutationInput = {
	name?: Prisma.StringFieldUpdateOperationsInput | string
	description?: Prisma.StringFieldUpdateOperationsInput | string
	value?: Prisma.StringFieldUpdateOperationsInput | string
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SettingsUncheckedUpdateManyInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number
	name?: Prisma.StringFieldUpdateOperationsInput | string
	description?: Prisma.StringFieldUpdateOperationsInput | string
	value?: Prisma.StringFieldUpdateOperationsInput | string
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SettingsOrderByRelevanceInput = {
	fields: Prisma.SettingsOrderByRelevanceFieldEnum | Prisma.SettingsOrderByRelevanceFieldEnum[]
	sort: Prisma.SortOrder
	search: string
}

export type SettingsCountOrderByAggregateInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	description?: Prisma.SortOrder
	value?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
}

export type SettingsAvgOrderByAggregateInput = {
	id?: Prisma.SortOrder
}

export type SettingsMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	description?: Prisma.SortOrder
	value?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
}

export type SettingsMinOrderByAggregateInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	description?: Prisma.SortOrder
	value?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
}

export type SettingsSumOrderByAggregateInput = {
	id?: Prisma.SortOrder
}

export type StringFieldUpdateOperationsInput = {
	set?: string
}

export type DateTimeFieldUpdateOperationsInput = {
	set?: Date | string
}

export type IntFieldUpdateOperationsInput = {
	set?: number
	increment?: number
	decrement?: number
	multiply?: number
	divide?: number
}

export type SettingsSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
	runtime.Types.Extensions.GetSelect<
		{
			id?: boolean
			name?: boolean
			description?: boolean
			value?: boolean
			createdAt?: boolean
			updatedAt?: boolean
		},
		ExtArgs['result']['settings']
	>

export type SettingsSelectScalar = {
	id?: boolean
	name?: boolean
	description?: boolean
	value?: boolean
	createdAt?: boolean
	updatedAt?: boolean
}

export type SettingsOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
	runtime.Types.Extensions.GetOmit<'id' | 'name' | 'description' | 'value' | 'createdAt' | 'updatedAt', ExtArgs['result']['settings']>

export type $SettingsPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	name: 'Settings'
	objects: {}
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: number
			name: string
			description: string
			value: string
			createdAt: Date
			updatedAt: Date
		},
		ExtArgs['result']['settings']
	>
	composites: {}
}

export type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = runtime.Types.Result.GetResult<
	Prisma.$SettingsPayload,
	S
>

export type SettingsCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<
	SettingsFindManyArgs,
	'select' | 'include' | 'distinct' | 'omit'
> & {
	select?: SettingsCountAggregateInputType | true
}

export interface SettingsDelegate<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings']; meta: { name: 'Settings' } }
	/**
	 * Find zero or one Settings that matches the filter.
	 * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
	 * @example
	 * // Get one Settings
	 * const settings = await prisma.settings.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends SettingsFindUniqueArgs>(
		args: Prisma.SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
	 * @example
	 * // Get one Settings
	 * const settings = await prisma.settings.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find the first Settings that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
	 * @example
	 * // Get one Settings
	 * const settings = await prisma.settings.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends SettingsFindFirstArgs>(
		args?: Prisma.SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find the first Settings that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
	 * @example
	 * // Get one Settings
	 * const settings = await prisma.settings.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find zero or more Settings that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Settings
	 * const settings = await prisma.settings.findMany()
	 *
	 * // Get first 10 Settings
	 * const settings = await prisma.settings.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends SettingsFindManyArgs>(
		args?: Prisma.SelectSubset<T, SettingsFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

	/**
	 * Create a Settings.
	 * @param {SettingsCreateArgs} args - Arguments to create a Settings.
	 * @example
	 * // Create one Settings
	 * const Settings = await prisma.settings.create({
	 *   data: {
	 *     // ... data to create a Settings
	 *   }
	 * })
	 *
	 */
	create<T extends SettingsCreateArgs>(
		args: Prisma.SelectSubset<T, SettingsCreateArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Create many Settings.
	 * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
	 * @example
	 * // Create many Settings
	 * const settings = await prisma.settings.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends SettingsCreateManyArgs>(
		args?: Prisma.SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>

	/**
	 * Delete a Settings.
	 * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
	 * @example
	 * // Delete one Settings
	 * const Settings = await prisma.settings.delete({
	 *   where: {
	 *     // ... filter to delete one Settings
	 *   }
	 * })
	 *
	 */
	delete<T extends SettingsDeleteArgs>(
		args: Prisma.SelectSubset<T, SettingsDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Update one Settings.
	 * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
	 * @example
	 * // Update one Settings
	 * const settings = await prisma.settings.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends SettingsUpdateArgs>(
		args: Prisma.SelectSubset<T, SettingsUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Delete zero or more Settings.
	 * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
	 * @example
	 * // Delete a few Settings
	 * const { count } = await prisma.settings.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends SettingsDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>

	/**
	 * Update zero or more Settings.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Settings
	 * const settings = await prisma.settings.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends SettingsUpdateManyArgs>(
		args: Prisma.SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>

	/**
	 * Create or update one Settings.
	 * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
	 * @example
	 * // Update or create a Settings
	 * const settings = await prisma.settings.upsert({
	 *   create: {
	 *     // ... data to create a Settings
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Settings we want to update
	 *   }
	 * })
	 */
	upsert<T extends SettingsUpsertArgs>(
		args: Prisma.SelectSubset<T, SettingsUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__SettingsClient<
		runtime.Types.Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Count the number of Settings.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
	 * @example
	 * // Count the number of Settings
	 * const count = await prisma.settings.count({
	 *   where: {
	 *     // ... the filter for the Settings we want to count
	 *   }
	 * })
	 **/
	count<T extends SettingsCountArgs>(
		args?: Prisma.Subset<T, SettingsCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<'select', any>
			? T['select'] extends true
				? number
				: Prisma.GetScalarType<T['select'], SettingsCountAggregateOutputType>
			: number
	>

	/**
	 * Allows you to perform aggregations operations on a Settings.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends SettingsAggregateArgs>(
		args: Prisma.Subset<T, SettingsAggregateArgs>,
	): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

	/**
	 * Group by Settings.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {SettingsGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends SettingsGroupByArgs,
		HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<T>>, Prisma.Extends<'take', Prisma.Keys<T>>>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: SettingsGroupByArgs['orderBy'] }
			: { orderBy?: SettingsGroupByArgs['orderBy'] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
		ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T['having']>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
					}[HavingFields]
				: 'take' extends Prisma.Keys<T>
					? 'orderBy' extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: 'skip' extends Prisma.Keys<T>
						? 'orderBy' extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors,
	): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
	/**
	 * Fields of the Settings model
	 */
	readonly fields: SettingsFieldRefs
}

/**
 * The delegate class that acts as a "Promise-like" for Settings.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__SettingsClient<
	T,
	Null = never,
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: 'PrismaPromise'
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
		onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
	): runtime.Types.Utils.JsPromise<T | TResult>
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}

/**
 * Fields of the Settings model
 */
export interface SettingsFieldRefs {
	readonly id: Prisma.FieldRef<'Settings', 'Int'>
	readonly name: Prisma.FieldRef<'Settings', 'String'>
	readonly description: Prisma.FieldRef<'Settings', 'String'>
	readonly value: Prisma.FieldRef<'Settings', 'String'>
	readonly createdAt: Prisma.FieldRef<'Settings', 'DateTime'>
	readonly updatedAt: Prisma.FieldRef<'Settings', 'DateTime'>
}

// Custom InputTypes
/**
 * Settings findUnique
 */
export type SettingsFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * Filter, which Settings to fetch.
	 */
	where: Prisma.SettingsWhereUniqueInput
}

/**
 * Settings findUniqueOrThrow
 */
export type SettingsFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * Filter, which Settings to fetch.
	 */
	where: Prisma.SettingsWhereUniqueInput
}

/**
 * Settings findFirst
 */
export type SettingsFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * Filter, which Settings to fetch.
	 */
	where?: Prisma.SettingsWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Settings to fetch.
	 */
	orderBy?: Prisma.SettingsOrderByWithRelationInput | Prisma.SettingsOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Settings.
	 */
	cursor?: Prisma.SettingsWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Settings from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Settings.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Settings.
	 */
	distinct?: Prisma.SettingsScalarFieldEnum | Prisma.SettingsScalarFieldEnum[]
}

/**
 * Settings findFirstOrThrow
 */
export type SettingsFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * Filter, which Settings to fetch.
	 */
	where?: Prisma.SettingsWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Settings to fetch.
	 */
	orderBy?: Prisma.SettingsOrderByWithRelationInput | Prisma.SettingsOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Settings.
	 */
	cursor?: Prisma.SettingsWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Settings from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Settings.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Settings.
	 */
	distinct?: Prisma.SettingsScalarFieldEnum | Prisma.SettingsScalarFieldEnum[]
}

/**
 * Settings findMany
 */
export type SettingsFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * Filter, which Settings to fetch.
	 */
	where?: Prisma.SettingsWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Settings to fetch.
	 */
	orderBy?: Prisma.SettingsOrderByWithRelationInput | Prisma.SettingsOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Settings.
	 */
	cursor?: Prisma.SettingsWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Settings from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Settings.
	 */
	skip?: number
	distinct?: Prisma.SettingsScalarFieldEnum | Prisma.SettingsScalarFieldEnum[]
}

/**
 * Settings create
 */
export type SettingsCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * The data needed to create a Settings.
	 */
	data: Prisma.XOR<Prisma.SettingsCreateInput, Prisma.SettingsUncheckedCreateInput>
}

/**
 * Settings createMany
 */
export type SettingsCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * The data used to create many Settings.
	 */
	data: Prisma.SettingsCreateManyInput | Prisma.SettingsCreateManyInput[]
	skipDuplicates?: boolean
}

/**
 * Settings update
 */
export type SettingsUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * The data needed to update a Settings.
	 */
	data: Prisma.XOR<Prisma.SettingsUpdateInput, Prisma.SettingsUncheckedUpdateInput>
	/**
	 * Choose, which Settings to update.
	 */
	where: Prisma.SettingsWhereUniqueInput
}

/**
 * Settings updateMany
 */
export type SettingsUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * The data used to update Settings.
	 */
	data: Prisma.XOR<Prisma.SettingsUpdateManyMutationInput, Prisma.SettingsUncheckedUpdateManyInput>
	/**
	 * Filter which Settings to update
	 */
	where?: Prisma.SettingsWhereInput
	/**
	 * Limit how many Settings to update.
	 */
	limit?: number
}

/**
 * Settings upsert
 */
export type SettingsUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * The filter to search for the Settings to update in case it exists.
	 */
	where: Prisma.SettingsWhereUniqueInput
	/**
	 * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
	 */
	create: Prisma.XOR<Prisma.SettingsCreateInput, Prisma.SettingsUncheckedCreateInput>
	/**
	 * In case the Settings was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<Prisma.SettingsUpdateInput, Prisma.SettingsUncheckedUpdateInput>
}

/**
 * Settings delete
 */
export type SettingsDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
	/**
	 * Filter which Settings to delete.
	 */
	where: Prisma.SettingsWhereUniqueInput
}

/**
 * Settings deleteMany
 */
export type SettingsDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Filter which Settings to delete
	 */
	where?: Prisma.SettingsWhereInput
	/**
	 * Limit how many Settings to delete.
	 */
	limit?: number
}

/**
 * Settings without action
 */
export type SettingsDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the Settings
	 */
	select?: Prisma.SettingsSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Settings
	 */
	omit?: Prisma.SettingsOmit<ExtArgs> | null
}

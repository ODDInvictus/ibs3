/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `FinancialGroup` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client'
import type * as $Enums from '../enums.js'
import type * as Prisma from '../internal/prismaNamespace.js'

/**
 * Model FinancialGroup
 *
 */
export type FinancialGroupModel = runtime.Types.Result.DefaultSelection<Prisma.$FinancialGroupPayload>

export type AggregateFinancialGroup = {
	_count: FinancialGroupCountAggregateOutputType | null
	_avg: FinancialGroupAvgAggregateOutputType | null
	_sum: FinancialGroupSumAggregateOutputType | null
	_min: FinancialGroupMinAggregateOutputType | null
	_max: FinancialGroupMaxAggregateOutputType | null
}

export type FinancialGroupAvgAggregateOutputType = {
	personId: number | null
}

export type FinancialGroupSumAggregateOutputType = {
	personId: number | null
}

export type FinancialGroupMinAggregateOutputType = {
	personId: number | null
}

export type FinancialGroupMaxAggregateOutputType = {
	personId: number | null
}

export type FinancialGroupCountAggregateOutputType = {
	personId: number
	_all: number
}

export type FinancialGroupAvgAggregateInputType = {
	personId?: true
}

export type FinancialGroupSumAggregateInputType = {
	personId?: true
}

export type FinancialGroupMinAggregateInputType = {
	personId?: true
}

export type FinancialGroupMaxAggregateInputType = {
	personId?: true
}

export type FinancialGroupCountAggregateInputType = {
	personId?: true
	_all?: true
}

export type FinancialGroupAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Filter which FinancialGroup to aggregate.
	 */
	where?: Prisma.FinancialGroupWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of FinancialGroups to fetch.
	 */
	orderBy?: Prisma.FinancialGroupOrderByWithRelationInput | Prisma.FinancialGroupOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.FinancialGroupWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` FinancialGroups from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` FinancialGroups.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned FinancialGroups
	 **/
	_count?: true | FinancialGroupCountAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: FinancialGroupAvgAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: FinancialGroupSumAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: FinancialGroupMinAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: FinancialGroupMaxAggregateInputType
}

export type GetFinancialGroupAggregateType<T extends FinancialGroupAggregateArgs> = {
	[P in keyof T & keyof AggregateFinancialGroup]: P extends '_count' | 'count'
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateFinancialGroup[P]>
		: Prisma.GetScalarType<T[P], AggregateFinancialGroup[P]>
}

export type FinancialGroupGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	where?: Prisma.FinancialGroupWhereInput
	orderBy?: Prisma.FinancialGroupOrderByWithAggregationInput | Prisma.FinancialGroupOrderByWithAggregationInput[]
	by: Prisma.FinancialGroupScalarFieldEnum[] | Prisma.FinancialGroupScalarFieldEnum
	having?: Prisma.FinancialGroupScalarWhereWithAggregatesInput
	take?: number
	skip?: number
	_count?: FinancialGroupCountAggregateInputType | true
	_avg?: FinancialGroupAvgAggregateInputType
	_sum?: FinancialGroupSumAggregateInputType
	_min?: FinancialGroupMinAggregateInputType
	_max?: FinancialGroupMaxAggregateInputType
}

export type FinancialGroupGroupByOutputType = {
	personId: number
	_count: FinancialGroupCountAggregateOutputType | null
	_avg: FinancialGroupAvgAggregateOutputType | null
	_sum: FinancialGroupSumAggregateOutputType | null
	_min: FinancialGroupMinAggregateOutputType | null
	_max: FinancialGroupMaxAggregateOutputType | null
}

type GetFinancialGroupGroupByPayload<T extends FinancialGroupGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<FinancialGroupGroupByOutputType, T['by']> & {
			[P in keyof T & keyof FinancialGroupGroupByOutputType]: P extends '_count'
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], FinancialGroupGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], FinancialGroupGroupByOutputType[P]>
		}
	>
>

export type FinancialGroupWhereInput = {
	AND?: Prisma.FinancialGroupWhereInput | Prisma.FinancialGroupWhereInput[]
	OR?: Prisma.FinancialGroupWhereInput[]
	NOT?: Prisma.FinancialGroupWhereInput | Prisma.FinancialGroupWhereInput[]
	personId?: Prisma.IntFilter<'FinancialGroup'> | number
	person?: Prisma.XOR<Prisma.FinancialPersonScalarRelationFilter, Prisma.FinancialPersonWhereInput>
	elements?: Prisma.FinancialGroupPersonElementListRelationFilter
}

export type FinancialGroupOrderByWithRelationInput = {
	personId?: Prisma.SortOrder
	person?: Prisma.FinancialPersonOrderByWithRelationInput
	elements?: Prisma.FinancialGroupPersonElementOrderByRelationAggregateInput
}

export type FinancialGroupWhereUniqueInput = Prisma.AtLeast<
	{
		personId?: number
		AND?: Prisma.FinancialGroupWhereInput | Prisma.FinancialGroupWhereInput[]
		OR?: Prisma.FinancialGroupWhereInput[]
		NOT?: Prisma.FinancialGroupWhereInput | Prisma.FinancialGroupWhereInput[]
		person?: Prisma.XOR<Prisma.FinancialPersonScalarRelationFilter, Prisma.FinancialPersonWhereInput>
		elements?: Prisma.FinancialGroupPersonElementListRelationFilter
	},
	'personId'
>

export type FinancialGroupOrderByWithAggregationInput = {
	personId?: Prisma.SortOrder
	_count?: Prisma.FinancialGroupCountOrderByAggregateInput
	_avg?: Prisma.FinancialGroupAvgOrderByAggregateInput
	_max?: Prisma.FinancialGroupMaxOrderByAggregateInput
	_min?: Prisma.FinancialGroupMinOrderByAggregateInput
	_sum?: Prisma.FinancialGroupSumOrderByAggregateInput
}

export type FinancialGroupScalarWhereWithAggregatesInput = {
	AND?: Prisma.FinancialGroupScalarWhereWithAggregatesInput | Prisma.FinancialGroupScalarWhereWithAggregatesInput[]
	OR?: Prisma.FinancialGroupScalarWhereWithAggregatesInput[]
	NOT?: Prisma.FinancialGroupScalarWhereWithAggregatesInput | Prisma.FinancialGroupScalarWhereWithAggregatesInput[]
	personId?: Prisma.IntWithAggregatesFilter<'FinancialGroup'> | number
}

export type FinancialGroupCreateInput = {
	person: Prisma.FinancialPersonCreateNestedOneWithoutFinancialGroupInput
	elements?: Prisma.FinancialGroupPersonElementCreateNestedManyWithoutGroupInput
}

export type FinancialGroupUncheckedCreateInput = {
	personId: number
	elements?: Prisma.FinancialGroupPersonElementUncheckedCreateNestedManyWithoutGroupInput
}

export type FinancialGroupUpdateInput = {
	person?: Prisma.FinancialPersonUpdateOneRequiredWithoutFinancialGroupNestedInput
	elements?: Prisma.FinancialGroupPersonElementUpdateManyWithoutGroupNestedInput
}

export type FinancialGroupUncheckedUpdateInput = {
	personId?: Prisma.IntFieldUpdateOperationsInput | number
	elements?: Prisma.FinancialGroupPersonElementUncheckedUpdateManyWithoutGroupNestedInput
}

export type FinancialGroupCreateManyInput = {
	personId: number
}

export type FinancialGroupUpdateManyMutationInput = {}

export type FinancialGroupUncheckedUpdateManyInput = {
	personId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type FinancialGroupNullableScalarRelationFilter = {
	is?: Prisma.FinancialGroupWhereInput | null
	isNot?: Prisma.FinancialGroupWhereInput | null
}

export type FinancialGroupCountOrderByAggregateInput = {
	personId?: Prisma.SortOrder
}

export type FinancialGroupAvgOrderByAggregateInput = {
	personId?: Prisma.SortOrder
}

export type FinancialGroupMaxOrderByAggregateInput = {
	personId?: Prisma.SortOrder
}

export type FinancialGroupMinOrderByAggregateInput = {
	personId?: Prisma.SortOrder
}

export type FinancialGroupSumOrderByAggregateInput = {
	personId?: Prisma.SortOrder
}

export type FinancialGroupScalarRelationFilter = {
	is?: Prisma.FinancialGroupWhereInput
	isNot?: Prisma.FinancialGroupWhereInput
}

export type FinancialGroupCreateNestedOneWithoutPersonInput = {
	create?: Prisma.XOR<Prisma.FinancialGroupCreateWithoutPersonInput, Prisma.FinancialGroupUncheckedCreateWithoutPersonInput>
	connectOrCreate?: Prisma.FinancialGroupCreateOrConnectWithoutPersonInput
	connect?: Prisma.FinancialGroupWhereUniqueInput
}

export type FinancialGroupUncheckedCreateNestedOneWithoutPersonInput = {
	create?: Prisma.XOR<Prisma.FinancialGroupCreateWithoutPersonInput, Prisma.FinancialGroupUncheckedCreateWithoutPersonInput>
	connectOrCreate?: Prisma.FinancialGroupCreateOrConnectWithoutPersonInput
	connect?: Prisma.FinancialGroupWhereUniqueInput
}

export type FinancialGroupUpdateOneWithoutPersonNestedInput = {
	create?: Prisma.XOR<Prisma.FinancialGroupCreateWithoutPersonInput, Prisma.FinancialGroupUncheckedCreateWithoutPersonInput>
	connectOrCreate?: Prisma.FinancialGroupCreateOrConnectWithoutPersonInput
	upsert?: Prisma.FinancialGroupUpsertWithoutPersonInput
	disconnect?: Prisma.FinancialGroupWhereInput | boolean
	delete?: Prisma.FinancialGroupWhereInput | boolean
	connect?: Prisma.FinancialGroupWhereUniqueInput
	update?: Prisma.XOR<
		Prisma.XOR<Prisma.FinancialGroupUpdateToOneWithWhereWithoutPersonInput, Prisma.FinancialGroupUpdateWithoutPersonInput>,
		Prisma.FinancialGroupUncheckedUpdateWithoutPersonInput
	>
}

export type FinancialGroupUncheckedUpdateOneWithoutPersonNestedInput = {
	create?: Prisma.XOR<Prisma.FinancialGroupCreateWithoutPersonInput, Prisma.FinancialGroupUncheckedCreateWithoutPersonInput>
	connectOrCreate?: Prisma.FinancialGroupCreateOrConnectWithoutPersonInput
	upsert?: Prisma.FinancialGroupUpsertWithoutPersonInput
	disconnect?: Prisma.FinancialGroupWhereInput | boolean
	delete?: Prisma.FinancialGroupWhereInput | boolean
	connect?: Prisma.FinancialGroupWhereUniqueInput
	update?: Prisma.XOR<
		Prisma.XOR<Prisma.FinancialGroupUpdateToOneWithWhereWithoutPersonInput, Prisma.FinancialGroupUpdateWithoutPersonInput>,
		Prisma.FinancialGroupUncheckedUpdateWithoutPersonInput
	>
}

export type FinancialGroupCreateNestedOneWithoutElementsInput = {
	create?: Prisma.XOR<Prisma.FinancialGroupCreateWithoutElementsInput, Prisma.FinancialGroupUncheckedCreateWithoutElementsInput>
	connectOrCreate?: Prisma.FinancialGroupCreateOrConnectWithoutElementsInput
	connect?: Prisma.FinancialGroupWhereUniqueInput
}

export type FinancialGroupUpdateOneRequiredWithoutElementsNestedInput = {
	create?: Prisma.XOR<Prisma.FinancialGroupCreateWithoutElementsInput, Prisma.FinancialGroupUncheckedCreateWithoutElementsInput>
	connectOrCreate?: Prisma.FinancialGroupCreateOrConnectWithoutElementsInput
	upsert?: Prisma.FinancialGroupUpsertWithoutElementsInput
	connect?: Prisma.FinancialGroupWhereUniqueInput
	update?: Prisma.XOR<
		Prisma.XOR<Prisma.FinancialGroupUpdateToOneWithWhereWithoutElementsInput, Prisma.FinancialGroupUpdateWithoutElementsInput>,
		Prisma.FinancialGroupUncheckedUpdateWithoutElementsInput
	>
}

export type FinancialGroupCreateWithoutPersonInput = {
	elements?: Prisma.FinancialGroupPersonElementCreateNestedManyWithoutGroupInput
}

export type FinancialGroupUncheckedCreateWithoutPersonInput = {
	elements?: Prisma.FinancialGroupPersonElementUncheckedCreateNestedManyWithoutGroupInput
}

export type FinancialGroupCreateOrConnectWithoutPersonInput = {
	where: Prisma.FinancialGroupWhereUniqueInput
	create: Prisma.XOR<Prisma.FinancialGroupCreateWithoutPersonInput, Prisma.FinancialGroupUncheckedCreateWithoutPersonInput>
}

export type FinancialGroupUpsertWithoutPersonInput = {
	update: Prisma.XOR<Prisma.FinancialGroupUpdateWithoutPersonInput, Prisma.FinancialGroupUncheckedUpdateWithoutPersonInput>
	create: Prisma.XOR<Prisma.FinancialGroupCreateWithoutPersonInput, Prisma.FinancialGroupUncheckedCreateWithoutPersonInput>
	where?: Prisma.FinancialGroupWhereInput
}

export type FinancialGroupUpdateToOneWithWhereWithoutPersonInput = {
	where?: Prisma.FinancialGroupWhereInput
	data: Prisma.XOR<Prisma.FinancialGroupUpdateWithoutPersonInput, Prisma.FinancialGroupUncheckedUpdateWithoutPersonInput>
}

export type FinancialGroupUpdateWithoutPersonInput = {
	elements?: Prisma.FinancialGroupPersonElementUpdateManyWithoutGroupNestedInput
}

export type FinancialGroupUncheckedUpdateWithoutPersonInput = {
	elements?: Prisma.FinancialGroupPersonElementUncheckedUpdateManyWithoutGroupNestedInput
}

export type FinancialGroupCreateWithoutElementsInput = {
	person: Prisma.FinancialPersonCreateNestedOneWithoutFinancialGroupInput
}

export type FinancialGroupUncheckedCreateWithoutElementsInput = {
	personId: number
}

export type FinancialGroupCreateOrConnectWithoutElementsInput = {
	where: Prisma.FinancialGroupWhereUniqueInput
	create: Prisma.XOR<Prisma.FinancialGroupCreateWithoutElementsInput, Prisma.FinancialGroupUncheckedCreateWithoutElementsInput>
}

export type FinancialGroupUpsertWithoutElementsInput = {
	update: Prisma.XOR<Prisma.FinancialGroupUpdateWithoutElementsInput, Prisma.FinancialGroupUncheckedUpdateWithoutElementsInput>
	create: Prisma.XOR<Prisma.FinancialGroupCreateWithoutElementsInput, Prisma.FinancialGroupUncheckedCreateWithoutElementsInput>
	where?: Prisma.FinancialGroupWhereInput
}

export type FinancialGroupUpdateToOneWithWhereWithoutElementsInput = {
	where?: Prisma.FinancialGroupWhereInput
	data: Prisma.XOR<Prisma.FinancialGroupUpdateWithoutElementsInput, Prisma.FinancialGroupUncheckedUpdateWithoutElementsInput>
}

export type FinancialGroupUpdateWithoutElementsInput = {
	person?: Prisma.FinancialPersonUpdateOneRequiredWithoutFinancialGroupNestedInput
}

export type FinancialGroupUncheckedUpdateWithoutElementsInput = {
	personId?: Prisma.IntFieldUpdateOperationsInput | number
}

/**
 * Count Type FinancialGroupCountOutputType
 */

export type FinancialGroupCountOutputType = {
	elements: number
}

export type FinancialGroupCountOutputTypeSelect<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	elements?: boolean | FinancialGroupCountOutputTypeCountElementsArgs
}

/**
 * FinancialGroupCountOutputType without action
 */
export type FinancialGroupCountOutputTypeDefaultArgs<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the FinancialGroupCountOutputType
	 */
	select?: Prisma.FinancialGroupCountOutputTypeSelect<ExtArgs> | null
}

/**
 * FinancialGroupCountOutputType without action
 */
export type FinancialGroupCountOutputTypeCountElementsArgs<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.FinancialGroupPersonElementWhereInput
}

export type FinancialGroupSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
	runtime.Types.Extensions.GetSelect<
		{
			personId?: boolean
			person?: boolean | Prisma.FinancialPersonDefaultArgs<ExtArgs>
			elements?: boolean | Prisma.FinancialGroup$elementsArgs<ExtArgs>
			_count?: boolean | Prisma.FinancialGroupCountOutputTypeDefaultArgs<ExtArgs>
		},
		ExtArgs['result']['financialGroup']
	>

export type FinancialGroupSelectScalar = {
	personId?: boolean
}

export type FinancialGroupOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
	runtime.Types.Extensions.GetOmit<'personId', ExtArgs['result']['financialGroup']>
export type FinancialGroupInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	person?: boolean | Prisma.FinancialPersonDefaultArgs<ExtArgs>
	elements?: boolean | Prisma.FinancialGroup$elementsArgs<ExtArgs>
	_count?: boolean | Prisma.FinancialGroupCountOutputTypeDefaultArgs<ExtArgs>
}

export type $FinancialGroupPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	name: 'FinancialGroup'
	objects: {
		person: Prisma.$FinancialPersonPayload<ExtArgs>
		elements: Prisma.$FinancialGroupPersonElementPayload<ExtArgs>[]
	}
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			personId: number
		},
		ExtArgs['result']['financialGroup']
	>
	composites: {}
}

export type FinancialGroupGetPayload<S extends boolean | null | undefined | FinancialGroupDefaultArgs> = runtime.Types.Result.GetResult<
	Prisma.$FinancialGroupPayload,
	S
>

export type FinancialGroupCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = Omit<
	FinancialGroupFindManyArgs,
	'select' | 'include' | 'distinct' | 'omit'
> & {
	select?: FinancialGroupCountAggregateInputType | true
}

export interface FinancialGroupDelegate<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialGroup']; meta: { name: 'FinancialGroup' } }
	/**
	 * Find zero or one FinancialGroup that matches the filter.
	 * @param {FinancialGroupFindUniqueArgs} args - Arguments to find a FinancialGroup
	 * @example
	 * // Get one FinancialGroup
	 * const financialGroup = await prisma.financialGroup.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends FinancialGroupFindUniqueArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find one FinancialGroup that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {FinancialGroupFindUniqueOrThrowArgs} args - Arguments to find a FinancialGroup
	 * @example
	 * // Get one FinancialGroup
	 * const financialGroup = await prisma.financialGroup.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends FinancialGroupFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find the first FinancialGroup that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupFindFirstArgs} args - Arguments to find a FinancialGroup
	 * @example
	 * // Get one FinancialGroup
	 * const financialGroup = await prisma.financialGroup.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends FinancialGroupFindFirstArgs>(
		args?: Prisma.SelectSubset<T, FinancialGroupFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find the first FinancialGroup that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupFindFirstOrThrowArgs} args - Arguments to find a FinancialGroup
	 * @example
	 * // Get one FinancialGroup
	 * const financialGroup = await prisma.financialGroup.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends FinancialGroupFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, FinancialGroupFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Find zero or more FinancialGroups that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all FinancialGroups
	 * const financialGroups = await prisma.financialGroup.findMany()
	 *
	 * // Get first 10 FinancialGroups
	 * const financialGroups = await prisma.financialGroup.findMany({ take: 10 })
	 *
	 * // Only select the `personId`
	 * const financialGroupWithPersonIdOnly = await prisma.financialGroup.findMany({ select: { personId: true } })
	 *
	 */
	findMany<T extends FinancialGroupFindManyArgs>(
		args?: Prisma.SelectSubset<T, FinancialGroupFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>>

	/**
	 * Create a FinancialGroup.
	 * @param {FinancialGroupCreateArgs} args - Arguments to create a FinancialGroup.
	 * @example
	 * // Create one FinancialGroup
	 * const FinancialGroup = await prisma.financialGroup.create({
	 *   data: {
	 *     // ... data to create a FinancialGroup
	 *   }
	 * })
	 *
	 */
	create<T extends FinancialGroupCreateArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupCreateArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Create many FinancialGroups.
	 * @param {FinancialGroupCreateManyArgs} args - Arguments to create many FinancialGroups.
	 * @example
	 * // Create many FinancialGroups
	 * const financialGroup = await prisma.financialGroup.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends FinancialGroupCreateManyArgs>(
		args?: Prisma.SelectSubset<T, FinancialGroupCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>

	/**
	 * Delete a FinancialGroup.
	 * @param {FinancialGroupDeleteArgs} args - Arguments to delete one FinancialGroup.
	 * @example
	 * // Delete one FinancialGroup
	 * const FinancialGroup = await prisma.financialGroup.delete({
	 *   where: {
	 *     // ... filter to delete one FinancialGroup
	 *   }
	 * })
	 *
	 */
	delete<T extends FinancialGroupDeleteArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Update one FinancialGroup.
	 * @param {FinancialGroupUpdateArgs} args - Arguments to update one FinancialGroup.
	 * @example
	 * // Update one FinancialGroup
	 * const financialGroup = await prisma.financialGroup.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends FinancialGroupUpdateArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Delete zero or more FinancialGroups.
	 * @param {FinancialGroupDeleteManyArgs} args - Arguments to filter FinancialGroups to delete.
	 * @example
	 * // Delete a few FinancialGroups
	 * const { count } = await prisma.financialGroup.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends FinancialGroupDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, FinancialGroupDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>

	/**
	 * Update zero or more FinancialGroups.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many FinancialGroups
	 * const financialGroup = await prisma.financialGroup.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends FinancialGroupUpdateManyArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>

	/**
	 * Create or update one FinancialGroup.
	 * @param {FinancialGroupUpsertArgs} args - Arguments to update or create a FinancialGroup.
	 * @example
	 * // Update or create a FinancialGroup
	 * const financialGroup = await prisma.financialGroup.upsert({
	 *   create: {
	 *     // ... data to create a FinancialGroup
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the FinancialGroup we want to update
	 *   }
	 * })
	 */
	upsert<T extends FinancialGroupUpsertArgs>(
		args: Prisma.SelectSubset<T, FinancialGroupUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialGroupClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>

	/**
	 * Count the number of FinancialGroups.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupCountArgs} args - Arguments to filter FinancialGroups to count.
	 * @example
	 * // Count the number of FinancialGroups
	 * const count = await prisma.financialGroup.count({
	 *   where: {
	 *     // ... the filter for the FinancialGroups we want to count
	 *   }
	 * })
	 **/
	count<T extends FinancialGroupCountArgs>(
		args?: Prisma.Subset<T, FinancialGroupCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<'select', any>
			? T['select'] extends true
				? number
				: Prisma.GetScalarType<T['select'], FinancialGroupCountAggregateOutputType>
			: number
	>

	/**
	 * Allows you to perform aggregations operations on a FinancialGroup.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends FinancialGroupAggregateArgs>(
		args: Prisma.Subset<T, FinancialGroupAggregateArgs>,
	): Prisma.PrismaPromise<GetFinancialGroupAggregateType<T>>

	/**
	 * Group by FinancialGroup.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {FinancialGroupGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends FinancialGroupGroupByArgs,
		HasSelectOrTake extends Prisma.Or<Prisma.Extends<'skip', Prisma.Keys<T>>, Prisma.Extends<'take', Prisma.Keys<T>>>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: FinancialGroupGroupByArgs['orderBy'] }
			: { orderBy?: FinancialGroupGroupByArgs['orderBy'] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
		ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T['having']>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
					}[HavingFields]
				: 'take' extends Prisma.Keys<T>
					? 'orderBy' extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: 'skip' extends Prisma.Keys<T>
						? 'orderBy' extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields ? never : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, FinancialGroupGroupByArgs, OrderByArg> & InputErrors,
	): {} extends InputErrors ? GetFinancialGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
	/**
	 * Fields of the FinancialGroup model
	 */
	readonly fields: FinancialGroupFieldRefs
}

/**
 * The delegate class that acts as a "Promise-like" for FinancialGroup.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__FinancialGroupClient<
	T,
	Null = never,
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: 'PrismaPromise'
	person<T extends Prisma.FinancialPersonDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.FinancialPersonDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__FinancialPersonClient<
		runtime.Types.Result.GetResult<Prisma.$FinancialPersonPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions> | Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>
	elements<T extends Prisma.FinancialGroup$elementsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.FinancialGroup$elementsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<Prisma.$FinancialGroupPersonElementPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
	>
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
		onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
	): runtime.Types.Utils.JsPromise<T | TResult>
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}

/**
 * Fields of the FinancialGroup model
 */
export interface FinancialGroupFieldRefs {
	readonly personId: Prisma.FieldRef<'FinancialGroup', 'Int'>
}

// Custom InputTypes
/**
 * FinancialGroup findUnique
 */
export type FinancialGroupFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * Filter, which FinancialGroup to fetch.
	 */
	where: Prisma.FinancialGroupWhereUniqueInput
}

/**
 * FinancialGroup findUniqueOrThrow
 */
export type FinancialGroupFindUniqueOrThrowArgs<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * Filter, which FinancialGroup to fetch.
	 */
	where: Prisma.FinancialGroupWhereUniqueInput
}

/**
 * FinancialGroup findFirst
 */
export type FinancialGroupFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * Filter, which FinancialGroup to fetch.
	 */
	where?: Prisma.FinancialGroupWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of FinancialGroups to fetch.
	 */
	orderBy?: Prisma.FinancialGroupOrderByWithRelationInput | Prisma.FinancialGroupOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for FinancialGroups.
	 */
	cursor?: Prisma.FinancialGroupWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` FinancialGroups from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` FinancialGroups.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of FinancialGroups.
	 */
	distinct?: Prisma.FinancialGroupScalarFieldEnum | Prisma.FinancialGroupScalarFieldEnum[]
}

/**
 * FinancialGroup findFirstOrThrow
 */
export type FinancialGroupFindFirstOrThrowArgs<
	ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * Filter, which FinancialGroup to fetch.
	 */
	where?: Prisma.FinancialGroupWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of FinancialGroups to fetch.
	 */
	orderBy?: Prisma.FinancialGroupOrderByWithRelationInput | Prisma.FinancialGroupOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for FinancialGroups.
	 */
	cursor?: Prisma.FinancialGroupWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` FinancialGroups from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` FinancialGroups.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of FinancialGroups.
	 */
	distinct?: Prisma.FinancialGroupScalarFieldEnum | Prisma.FinancialGroupScalarFieldEnum[]
}

/**
 * FinancialGroup findMany
 */
export type FinancialGroupFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * Filter, which FinancialGroups to fetch.
	 */
	where?: Prisma.FinancialGroupWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of FinancialGroups to fetch.
	 */
	orderBy?: Prisma.FinancialGroupOrderByWithRelationInput | Prisma.FinancialGroupOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing FinancialGroups.
	 */
	cursor?: Prisma.FinancialGroupWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` FinancialGroups from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` FinancialGroups.
	 */
	skip?: number
	distinct?: Prisma.FinancialGroupScalarFieldEnum | Prisma.FinancialGroupScalarFieldEnum[]
}

/**
 * FinancialGroup create
 */
export type FinancialGroupCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * The data needed to create a FinancialGroup.
	 */
	data: Prisma.XOR<Prisma.FinancialGroupCreateInput, Prisma.FinancialGroupUncheckedCreateInput>
}

/**
 * FinancialGroup createMany
 */
export type FinancialGroupCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * The data used to create many FinancialGroups.
	 */
	data: Prisma.FinancialGroupCreateManyInput | Prisma.FinancialGroupCreateManyInput[]
	skipDuplicates?: boolean
}

/**
 * FinancialGroup update
 */
export type FinancialGroupUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * The data needed to update a FinancialGroup.
	 */
	data: Prisma.XOR<Prisma.FinancialGroupUpdateInput, Prisma.FinancialGroupUncheckedUpdateInput>
	/**
	 * Choose, which FinancialGroup to update.
	 */
	where: Prisma.FinancialGroupWhereUniqueInput
}

/**
 * FinancialGroup updateMany
 */
export type FinancialGroupUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * The data used to update FinancialGroups.
	 */
	data: Prisma.XOR<Prisma.FinancialGroupUpdateManyMutationInput, Prisma.FinancialGroupUncheckedUpdateManyInput>
	/**
	 * Filter which FinancialGroups to update
	 */
	where?: Prisma.FinancialGroupWhereInput
	/**
	 * Limit how many FinancialGroups to update.
	 */
	limit?: number
}

/**
 * FinancialGroup upsert
 */
export type FinancialGroupUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * The filter to search for the FinancialGroup to update in case it exists.
	 */
	where: Prisma.FinancialGroupWhereUniqueInput
	/**
	 * In case the FinancialGroup found by the `where` argument doesn't exist, create a new FinancialGroup with this data.
	 */
	create: Prisma.XOR<Prisma.FinancialGroupCreateInput, Prisma.FinancialGroupUncheckedCreateInput>
	/**
	 * In case the FinancialGroup was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<Prisma.FinancialGroupUpdateInput, Prisma.FinancialGroupUncheckedUpdateInput>
}

/**
 * FinancialGroup delete
 */
export type FinancialGroupDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
	/**
	 * Filter which FinancialGroup to delete.
	 */
	where: Prisma.FinancialGroupWhereUniqueInput
}

/**
 * FinancialGroup deleteMany
 */
export type FinancialGroupDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Filter which FinancialGroups to delete
	 */
	where?: Prisma.FinancialGroupWhereInput
	/**
	 * Limit how many FinancialGroups to delete.
	 */
	limit?: number
}

/**
 * FinancialGroup.elements
 */
export type FinancialGroup$elementsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroupPersonElement
	 */
	select?: Prisma.FinancialGroupPersonElementSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroupPersonElement
	 */
	omit?: Prisma.FinancialGroupPersonElementOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupPersonElementInclude<ExtArgs> | null
	where?: Prisma.FinancialGroupPersonElementWhereInput
	orderBy?: Prisma.FinancialGroupPersonElementOrderByWithRelationInput | Prisma.FinancialGroupPersonElementOrderByWithRelationInput[]
	cursor?: Prisma.FinancialGroupPersonElementWhereUniqueInput
	take?: number
	skip?: number
	distinct?: Prisma.FinancialGroupPersonElementScalarFieldEnum | Prisma.FinancialGroupPersonElementScalarFieldEnum[]
}

/**
 * FinancialGroup without action
 */
export type FinancialGroupDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
	/**
	 * Select specific fields to fetch from the FinancialGroup
	 */
	select?: Prisma.FinancialGroupSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the FinancialGroup
	 */
	omit?: Prisma.FinancialGroupOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FinancialGroupInclude<ExtArgs> | null
}
